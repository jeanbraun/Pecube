c*************************************************************************
c
c	Main subroutine NA  - sampling a parameter space
c		      	      using a Neighbourhood algorithm
c
c	Input files:
c		    na.in	- Options for Neighbourhood algorithm
c
c	Output files:
c		    na.sum	- summary of results
c		    na.nad	- NAD (NA direct access file of models)
c		    sobol.coeff	- initializing data used for 
c				  quasi-random sequences
c
c	Comments:
c		 The NAD file is a direct access compact format file
c		 containing all models generated by the neighbourhood
c		 algorithm. (NAD files can be read in by multi-dimensional 
c		 integration program NA-Bayes and plot program S-plot.)
c
c					M. Sambridge, (RSES, ANU)
c					Last revision Sept. 1999. 
c
c*************************************************************************
c
	Subroutine NA (ndin,rangein,run)
c
c						MPI definitions
cifdef MPI
       include "mpif.h"
cendif

        include 'na_param.inc'
c
c						Set up all dimensions for 
c						arrays used by NA routines
	real*4		misfit(nmod_max),
     &			misfitval,mfitmin,
     &                  mfitmean,mfitminc

	real*4		sum(nsample_max)
c
	real*4		na_models(nd_max*nmod_max),
     &			range(2,nd_max),
     &			ranget(2,nd_max),
     &			scales(nd_max+1),
     &			na_model(nd_max),
     &			xcur(nd_max)

      real*4            rangein(2,1024)
      integer           npin

        character       header*(nh_max)
        character*256   fnme

      	integer		mfitord(nsample_max)

      	real		work_NA1(nmod_max),
     &  		work_NA2(nmod_max)

      	integer		iwork_NA1(nmod_max),
     &  		iwork_NA2(nsample_max)

c
	logical		monte,
     &                  verbose,
     &                  summary,
     &                  timing,
     &                  debug,
     &                  check,
     &                  restartNA,
     &                  noforward,
     &                  calcmovement

	logical		lroot
c
c						Some bookeeping variables
c						not used by NA routines
c	real		acells(nit_max)
	real*4		model_opt(nd_max)

c added by Jean for compatibility for Pecube

        character*5 run

        integer         nproc, iproc, ierr

c
c						Info and Logical unit common 
c						blocks used by NA routines
c
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary


        common /NA_info/nxsave,ndsave,ndc,nerr,ncald,nupd,
     &                  cells,torder,taxis,tup,tcd,tdev,tna,tres

        common /NA_info_special/taxis2

        common /NA_MPI/iproc,nproc,lroot

c
c		Set up logical units 
c						LU's for standard output
        lu_out = 6
c
c
c	       	Set up logical units for Neighbourhood Algorithm files
c 
c						LU for input of NA options
c
	lu_na = 30
c						LU for input of quasi random
c						number generator data
c						(sobol sequence data)
 	lu_sob = 31
c						LU for output of information
c						summarising NA performance. 
        lu_sum = 32
c						LU for output of more detailed
c						information to file na.det
        lu_det = 33
c						LU for output of sample 
c						density in best voronoi cell
c						(Only used if calcmovement
c						 is set to true and NA_PDF
c						 is not used)
c						
c						LU for NAD input/output file
        lu_nad = 34
c						LU for special info file
 	lu_dis = 35

c						set up variables
c						and start MPI
	iproc = 0
	nproc = 1
	lroot = .false.

cifdef MPI
       call MPI_Init(ierr )
       call MPI_Comm_size( MPI_COMM_WORLD, nproc, ierr )
       call MPI_Comm_rank( MPI_COMM_WORLD, iproc, ierr )
c	write(*,*)' MPI called nproc = ',nproc
cendif
        if(iproc.eq.0)lroot = .true.

c	write(*,*)' I am node ',iproc,' lroot = ',lroot

c						User specific setup for 
c						forward modelling
c
        nd=ndin
        range(:,1:nd)=rangein(:,1:nd)
	call user_init(nd,range,scales)
c						
c						Open NA input files
c
	open(lu_na,file=run//'/NA/na.in',status='old')
c
c                                               Open NA output files
c
        if(lroot)open(lu_sum, file=run//'/NA/na.sum', status='unknown')

c						write header to standard out
	if(lroot)write(*,100)
c

c
c						Read in options for
c						Neighbourhood algorithm.
c
	call NA_options
     &       (nsample_max, nit_max, nmod_max, 
     &        nsleep_max, nd, nsamplei, nsample, istype, 
     &        noforward, nsleep, ncells, itmax, monte, nclean, run)

c						
c						Close NA input files
c
	close(lu_na)
c						set other info or debug options
        check = .true.
        check = .false.
        calcmovement = .true.
        calcmovement = .false.
        if(calcmovement)then
	  if(lroot)open(lu_dis, file='distances', status='unknown')
        end if
c
c						Initialize NA routines.
c
      	call NA_initialize
     &       (range,ranget,scales,
     &        nd,nd_max,xcur,nsample,ncells,restartNA)

c             		                	Generate or read in
c						starting models 
c
 	      call NA_initial_sample
     &       (na_models,nd,ranget,range,nsamplei,
     &        istype,monte,calcmovement,scales,misfit,run)
c
c			MAIN OPTIMIZATION LOOP
c
        ntot = 0
        nxsavet = 0
        ndsavet = 0
        ndct = 0
        nerrt = 0
        ncald = 0
        nupd = 0
        taxist = 0.
        taxist2 = 0.
        tordert = 0.
        tupt = 0.
        tcdt = 0.
        trest = 0.
        tdevt = 0.
        ttfor = 0.
        tmpi = 0.
        tmis = 0.
        tnat = 0.
        ns = nsamplei
         CALL MPI_BCAST
     &          (na_models, nd_max*nmod_max,
     &           MPI_REAL, 0, MPI_COMM_WORLD, ierr)


	do 20 it = 1,itmax+1
c
c						Calculate misfit values
c						for each model in the 
c						current population.
c
           if(summary.and.lroot)then
              write(*,*)
              write(*,*)' start forward modeling iteration: ',it-1
	   end if

c						skip forward modelling for
c						starting models if 
c						they have been read in 
c						from a NAD file

	   if(it.eq.1.and.noforward)go to 31
           t1 = cputime(t2,t3)
	   do 30 i = iproc+1,ns,nproc
c						Decode current model
c						and put into array model.
c
              ii = 1+(i-1+ntot)*nd

              call transform2raw
     &             (na_models(ii),nd,range,scales,na_model)

	      misfitval = 0.0
	      call forward(nd, na_model, misfitval, run, iproc)
c
              jj = ntot + i
	      misfit(jj) = misfitval
c
 30	   continue
           t1 = cputime(t2,t3)
           ttfor = ttfor + t2

c	   write(*,*)iproc,' : ',(misfit(k),k=1+ntot,ntot+ns)
cifdef MPI
          CALL MPI_ALLREDUCE
     &          (misfit(ntot+1), sum, ns,
     &           MPI_REAL, MPI_SUM, MPI_COMM_WORLD, ierr)
cendif

c	   write(*,*)iproc,' : ',(misfit(k),k=1+ntot,ntot+ns)

 31        if(summary.and.lroot)write(*,*)' finished forward modeling'

	   if(nproc.gt.1)then
	      do i=1,ns
                 misfit(ntot+i) = sum(i)
	      end do
	   end if

           t1 = cputime(t2,t3)
           tmpi = tmpi + t2
           tnat = tnat + t2
c
c						Calculate properties of
c						current misfit distribution.
c						(Mean,min,best model etc.)

 	   call NA_misfits
     &          (misfit,ns,it,ntot,mfitmin,
     &           mfitminc,mfitmean,mopt,
     &           ncells,work_NA2,
     &           iwork_NA1,iwork_NA2,mfitord)

           t1 = cputime(t2,t3)
           tmis = tmis + t2
           tnat = tnat + t2
c						copy optimum model from
c						current population, to
c						array model_opt.
c
           ii = 1 + (mopt-1)*nd
c
           call transform2raw
     &          (na_models(ii),nd,range,scales,na_model)

           do j=1,nd
              model_opt(j) = na_model(j)
           end do
c
	   ntot = ntot + ns
           ns = nsample
c						write out summary info
	   if(verbose.and.lroot)then
	      call NA_display
     &             (lu_det,model_opt,it-1,nd,ntot,
     &              mfitmin,mfitminc,mfitmean,mopt)
	   end if

	   if(it.eq.itmax+1)go to 99
c								     F I/O
c
c						Call main NA routines
c
	   if(monte)then
              t1 = cputime(t2,t3)
c						Perform Monte Carlo 
c						search for comparison
c						to NA.
 	      call NA_random
     &             (na_models,nd,ranget,
     &              ntot,nsample,calcmovement)

              t1 = cputime(t2,t3)
              tnat = tnat + t2

	   else 
c						generate a new sample using
c						Neighbourhood algorithm
c						(resample version)

      	      call NA_sample
     &             (na_models, ntot, nsample, nd, nsleep, 
     &              ncells, misfit, mfitord, ranget, 
     &              check, xcur, restartNA, 
     &              calcmovement, nclean, work_NA1)
c
c						collect info statistics
              nxsavet = nxsavet + nxsave
              ndsavet = ndsavet + ndsave
c             acells(it) = cells
              ndct = ndct + ndc
              nerrt = nerrt + nerr
              tordert = tordert + torder
              tupt = tupt + tup
              tcdt = tcdt + tcd
              trest = trest + tres
              tdevt = tdevt + tdev
              taxist = taxist + taxis
c             taxist2 = taxist2 + taxis2
              tnat = tnat + tna


	   end if

            CALL MPI_BCAST
     &          (na_models, nd_max*nmod_max,
     &           MPI_REAL, 0, MPI_COMM_WORLD, ierr)

c
 20	continue
c
c			FINISHED OPTIMIZATION LOOP
c
 99     continue
c
c					Some statistics

	if(summary.and.lroot)then

        write(*,*)' '
        write(*,*)' '
        write(*,*)' '
        write(*,*)'Performance statistics'
        write(*,*)' '
c       write(*,*)'Total number of x saves               ',nxsavet
c       write(*,*)'Total number of d saves               ',ndsavet
c       write(*,*)'Total number of distance evaluations  ',ndct
        write(*,*)'Total number of full dlist evaluations',ncald
        write(*,*)'Total number of partial dlist updates ',nupd
        write(*,*)'Lowest misfit found                   ',mfitmin
        write(*,*)'Average misfit over all models        ',mfitmean
        write(*,*)'Index of lowest misfit model          ',mopt
        write(*,*)
        write(lu_sum,*)
        write(lu_sum,*)
        write(lu_sum,*)
        write(lu_sum,*)'Performance statistics'
        write(lu_sum,*)' '
c       write(lu_sum,*)
c    &  'Total number of x saves                 ',nxsavet
c       write(lu_sum,*)
c    &  'Total number of d saves                 ',ndsavet
c       write(lu_sum,*)
c    &  'Total number of distance evaluations    ',ndct
        write(lu_sum,*)
     &  'Total number of full dlist evaluations  ',ncald
        write(lu_sum,*)
     &  'Total number of partial dlist updates   ',nupd
        write(lu_sum,*)
     &  'Lowest misfit found                     ',mfitmin
        write(lu_sum,*)
     &  'Average misfit over all models          ',mfitmean
        write(lu_sum,*)
     &  'Index of lowest misfit model            ',mopt
        write(lu_sum,*)

c       if(check)then
c          NNval=nd*naxis*nsample*itmax
c          write(*,*)'Total number of NN values ',nnval
c          write(lu_sum,*)'Total number of NN values ',nnval
c          write(*,*)'Total number of errors         ',nerrt
c          write(lu_sum,*)'Total number of errors         ',nerrt
c       end if

        write(lu_sum,*)
     &  'Total time spent updating dlist                ',tupt
        write(lu_sum,*)
     &  'Total time spent evaluating dlist              ',tcdt
        write(lu_sum,*)
     &  'Total time spent finding Voronoi intersections ',taxist
        write(lu_sum,*)
     &  'Total time spent calculating random deviates   ',tdevt
        write(lu_sum,*)
     &  'Total time resetting random walks              ',trest
        write(lu_sum,*)
     &  'Total time for ordering misfits                ',tmis
        if(nproc.gt.1)write(lu_sum,*)
     &  'Total time for MPI reduction                   ',tmpi
        write(lu_sum,*)
     &  'Total time for NA-algorithm (without forward)  ',tnat
        write(lu_sum,*)
     &  'Total time for forward modeling                ',ttfor
        write(lu_sum,*)

c       if(verbose)then
c          write(lu_sum,*)'Average number of cells per axis ',
c    &                    'for each sample'  
c          write(lu_sum,*)(acells(ii),ii=1,itmax)
c       end if
        write(*,*)
     &  'Total time spent updating dlist                ',tupt
        write(*,*)
     &  'Total time spent evaluating dlist              ',tcdt
        write(*,*)
     &  'Total time spent finding Voronoi intersections ',taxist
        write(*,*)
     &  'Total time spent calculating random deviates   ',tdevt
        write(*,*)
     &  'Total time resetting random walks              ',trest
        write(*,*)
     &  'Total time for ordering misfits                ',tmis
        if(nproc.gt.1)write(*,*)
     &  'Total time for MPI reduction                   ',tmpi
        write(*,*)
     &  'Total time for NA-algorithm (without forward)  ',tnat
        write(*,*)
     &  'Total time for forward modeling                ',ttfor
        write(*,*)

	end if

c						transform all models
c						back to scaled units
	do i=1,ntot
           ii = 1 + (i-1)*nd
           call transform2raw
     &          (na_models(ii),nd,range,scales,na_models(ii))
 	end do

	nh = 1
c						call user supplied I/O routine
	if(lroot)call writemodels 
     &       (nd, ntot, na_models, misfit,
     &        nsamplei, nsample, itmax, nh_max, nh, header, run)
c
c
c                                               write out ensemble of models
c                                               as a direct access file
	
c						add NA-info to begining
c						of header file
c
        fnme = run//'/NA/na.nad'
	if (lroot) call NA_header
     &       (lu_nad,fnme,header,nh_max,nh,nd,
     &        range,scales,nsamplei,nsample,ncells,nh_user)

c
	if(summary.and.lroot)then
           write(*,*)' Total length of header in (nad) direct ',
     &               ' access model file = ',nh
           write(*,*)
           write(*,*)' Writing direct access file...'
           write(*,*)
	end if
c                                               write direct access nad file
 
        fnme = run//'/NA/na.nad'
        if(lroot)call write_nad
     &       (lu_nad,fnme,nd,ntot,
     &        nh,nh_user,header,1,na_models,misfit)

c						
c						Close NA summary file
c
	if(lroot)close(lu_sum)
	if(lroot)close(lu_det)
	close(lu_sob)
        if(calcmovement)close(lu_dis)
c						Advise of files created
	if(lroot)then

	write(*,*)
	write(*,*)' Files created:'
	write(*,*)
	write(*,*)
     &  ' na.nad : Direct access file containing ensemble of models ' 
	write(*,*)
     &  ' na.sum : Short summary file of progress' 
	if(verbose)write(*,*)
     &  ' na.det : Full details of progress' 
	write(*,*)

	end if
c
 100    format(/1x,35('-')/
     &          1x,'|',33x,'|'/
     &          1x,'|',5x,'Parameter space search',6x,'|'/,
     &          1x,'|',' using a Neighbourhood Algorithm ','|'/
     &          1x,'|',33x,'|'/
     &          1x,35('-')/)
 
cifdef MPI
         call MPI_Finalize(ierr)
cendif

	return
	end
c
c ----------------------------------------------------------------------------
c
c       NA_options - reads in all input options for NA algorithm.
c
c       Calls no other routines.
c
c	Comments:
c                This routine assumes that direct access
c                files are opened with the record length specified
c                in bytes. This is the default for most machines
c                but not Dec machines. (Often a compiler option is
c                available on the DEC/compaq to use bytes rather than 
c                4-byte words.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_options
     &             (nsample_max, nit_max, nmod_max,
     &              nsleep_max, nd, nsamplei, nsample, istype, 
     &		    noforward, nsleep, ncells, itmax, monte, nclean, run)

	logical		monte
	logical		verbose
	logical		summary
	logical		timing
	logical		debug
	logical		sobol
	logical		noforward
	logical		lroot

	character*1	yesorno
        character*5 run

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

        common/randomtype/sobol,iseed

        common /NA_MPI/iproc,nproc,lroot
c
c                                               Write header to summary file.
        if(lroot)write(lu_sum,300)
c
c                               Question and answer session
c                               to read in NA options.
	do i=1,3
	   read(lu_na,*)
        end do
c                                               Note: logical unit for reading
c                                               in NA options (lu) may be set
c                                               to the screen (5) or a file.
c
        read(lu_na,*)itype
        monte = .false.
        if(itype.eq.1)then
           monte = .true.
        else if(itype.eq.0)then
c          shrink = .true.
c       else if(itype.eq.-1)then
c          shrink = .false.
        else
           write(*,*)' Error - in NA options file' 
           write(*,*)'         Invalid algorithm type entered ' 
           write(*,*)
	   call na_abort
        end if
c
c       write(lu_out,*)' Enter maximum number of iterations'
        read(lu_na,*)itmax
c
c       write(lu_out,*)' Enter sample size for initial population'
        read(lu_na,*)nsamplei
c
c       write(lu_out,*)' Enter sample size for remaining populations'
        read(lu_na,*)nsample
c
c       write(lu_out,*)' Enter number of models for re-sampling '
c       write(lu_out,*)' (1=only re-sample cell with lowest misfit)'
c       write(lu_out,*)' (n=re-sample best n cells)'
        read(lu_na,*)ncells

c       write(lu_out,*)' Enter length of walk from node before'
c    &                 ,' acceptance'
c       read(lu_na,*)nsleep
	nsleep = 1

c					removed option from input
c
c       write(lu_out,*)' Use Sobol-Antanov-Saleev ',
c    &                 'quasi-random sequence ?'
c       write(lu_out,*)' Enter y and idummy for SAS'
c       write(lu_out,*)' or    n and iseed for pseudo-random',
c    &                 ' sequence'
	yesorno = 'Y'
        read(lu_na,fmt='(a1,1x,i7)')yesorno,iseed
        sobol = .false.
	if(iseed.lt.0)then
	   iseed = -iseed
	end if
        if(yesorno.eq.'y'.or.yesorno.eq.'Y')sobol=.true.
c
c					read initial sample type
	read(lu_na,*)istype
        noforward = .false.
	if(istype.lt.0)then
	   istype = -istype
           noforward = .true.
	end if
c
c					read in size of initial 
c					sample from nad file
        if(istype.eq.1)then

           len = 16
           open(lu_nad,file=run//'/NA/na.nad',status='old',
     &          form='unformatted',access='direct',recl=len,err=20)
           read(lu_nad,rec=1)nd_nad,nsamplei,nh,nhu
           close(lu_nad)

	   if(nd_nad.ne.nd)then
	      write(*,*)
	      write(*,*)' Error detected in reading starting models',
     &        	        ' from NAD file'
	      write(*,*)
	      write(*,*)' Dimension of parameter space obtained'  
	      write(*,*)' from user provided subroutine user_init'  
	      write(*,*)' differs from that read in from NAD file'  
	      write(*,*)
	      write(*,*)' Perhaps this is the wrong NAD file ?'
	      write(*,*)' or user subroutine is in error ?'
	      write(*,*)
	      write(*,*)' Remedy: correct input NAD file or'
	      write(*,*)'         user_init and recompile'
	      write(*,*)
	      call na_abort
	   end if

           go to 21
 20           write(*,*)
	      write(*,*)' Error detected in reading starting models',
     &        	        ' from NAD file'
	      write(*,*)
	      write(*,*)' Cannot open file NA/na.nad'
	      write(*,*)' does it exist ?'
	      write(*,*)
	      write(*,*)' Remedy: ensure correct input NAD file'
	      write(*,*)'         is available for reading in'
	      write(*,*)
	      call na_abort
 21        continue

	end if

        ntotal = nsamplei + nsample*itmax
c
c					removed option from input
c
c       write(lu_out,*)' Enter frequency of re-initializing',
c    &                 ' distance list (per sample)'
c       write(lu_out,*)' (If the sample size is equal to 100'
c       write(lu_out,*)'  a value of 1 is usually adequate. '
c       write(lu_out,*)'  This will mean that the distance list'
c       write(lu_out,*)'  is re-initialized before each new'
c       write(lu_out,*)'  of samples is generated.'
c       write(lu_out,*)'  The smaller this parameter the less rounding' 
c       write(lu_out,*)'  error will effect nearest neighbour solution'
c       write(lu_out,*)'  but at the cost of increased computation.)'
c       read(lu_na,*)nclean
	nclean = 500

c       write(lu_out,*)' Use verbose mode ? (y/n)'
c       write(lu_out,*)' (Gives extra information per iteration)'
        read(lu_na,*)infolevel
        verbose = .false.
        summary = .false.
        if(infolevel.eq.1)summary=.true.
        if(infolevel.eq.2)summary=.true.
        if(infolevel.eq.2)verbose=.true.

c       write(lu_out,*)' Turn timing on ? (y/n)'
        read(lu_na,fmt='(a1)')yesorno
        timing = .false.
        if(yesorno.eq.'y'.or.yesorno.eq.'Y')timing=.true.

c       write(lu_out,*)' Turn debug mode on ? (y/n)'
c       write(lu_out,*)' (Gives full information)'
        read(lu_na,fmt='(a1)')yesorno
        debug = .false.
        if(yesorno.eq.'y'.or.yesorno.eq.'Y')debug=.true.
c
c						perform parameter checking
        nsam = max(nsample,nsamplei)
        if(nsam.gt.nsample_max)then
          write(lu_out,200)
          write(lu_out,*)' Size of sample is',
     &                   ' greater than the maximum.'
          write(lu_out,*)' nsample          = ',nsam
          write(lu_out,*)' maximum          = ',nsample_max
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Decrease sample size or'
          write(lu_out,*)'         increase parameter nsample_max'
          write(lu_out,*)'         and recompile'
          write(lu_out,*)' '
          call na_abort 
        else if(ntotal.gt.nmod_max)then
          write(lu_out,200)
          write(lu_out,*)' Number of models is',
     &                   ' greater than the maximum.'
          write(lu_out,*)' ntotal           = ',ntotal
          write(lu_out,*)' maximum          = ',nmod_max
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Increase maximum number '
          write(lu_out,*)'         of iterations and recompile'
          write(lu_out,*)' '
          call na_abort 
        else if(itmax.gt.nit_max)then
          write(lu_out,200)
          write(lu_out,*)' Number of iterations is',
     &                   ' greater than the maximum.'
          write(lu_out,*)' Number requested = ',itmax
          write(lu_out,*)' maximum          = ',nit_max
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Decrease number of iterations '
          write(lu_out,*)'         or increase parameter nit_max'
          write(lu_out,*)'         and recompile'
          write(lu_out,*)' '
          call na_abort 
c       else if(naxis.gt.naxis_max)then
c         write(lu_out,200)
c         write(lu_out,*)' Number of axis intervals is',
c    &                   ' greater than the maximum.'
c         write(lu_out,*)' Number requested = ',naxis
c         write(lu_out,*)' maximum          = ',naxis_max
c         write(lu_out,*)' '
c         write(lu_out,*)' Remedy: '
c         write(lu_out,*)'         Decrease number of intervals'
c         write(lu_out,*)'         or increase parameter naxis_max'
c         write(lu_out,*)'         and recompile'
c         write(lu_out,*)' '
c         call na_abort 
        end if
        if(ncells.gt.nsample.or.ncells.gt.nsamplei)then
          write(lu_out,200)
          write(lu_out,*)' Number cells to be re-sampled at each'
          write(lu_out,*)' iteration is greater than the sample size'
          write(lu_out,*)' Initial sample size  = ',nsamplei
          write(lu_out,*)' Sample size          = ',nsample
          write(lu_out,*)' Re-sample size       = ',ncells
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Decrease number of re-sampled cells'
          write(lu_out,*)'         or increase sample size'
          write(lu_out,*)' '
          call na_abort 
        else if(nsleep.gt.nsleep_max)then
          write(lu_out,200)
          write(lu_out,*)' Number of sleep steps is',
     &                   ' greater than the maximum.'
          write(lu_out,*)' nsleep          = ',nsleep
          write(lu_out,*)' maximum         = ',nsleep_max
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Decrease size of input'
          write(lu_out,*)'         variable nsleep or increase'
          write(lu_out,*)'         parameter nsleep_max and recompile'
          write(lu_out,*)' '
          call na_abort 
	end if
	if(istype.gt.2.or.istype.lt.0)then
          write(lu_out,200)
          write(lu_out,*)' Type of initial sample not recognized'
          write(lu_out,*)
          write(lu_out,*)' Input parameter appears to be :',istype
          write(lu_out,*)
          write(lu_out,*)' Only values 0, 1 and -1 currently supported'
          write(lu_out,*)
          write(lu_out,*)' type 0  = randomly generated internally'
          write(lu_out,*)' type 1  = read in from a NAD file '
          write(lu_out,*)' type -1 = same as 1 but perform forward',
     &                     ' modelling of initial sample'
          write(lu_out,*)
	  call na_abort
	end if
             
c
c                            Display NA options
c
	if(lroot)then

        write(lu_sum,100)
        write(lu_sum,fmt='("  Options set:"/)')
        if(monte)then
           write(lu_sum,*)' Uniform Monte Carlo Algorithm'
        else
           write(lu_sum,*)' Neighbourhood Algorithm'
        end if
        write(lu_sum,*)' Initial sample size           : ',nsamplei
        write(lu_sum,*)' Sample size                   : ',nsample
        write(lu_sum,*)' Total number of iterations    : ',itmax
c       write(lu_sum,*)' Number of axis samples        : ',naxis
c       write(lu_sum,*)' Number of samples per reset   '
c       write(lu_sum,*)' of distance database          : ',nclean
        write(lu_sum,*)' Number of cells re-sampled    : ',ncells
        write(lu_sum,*)' Total number of models        : ',ntotal
c       write(lu_sum,*)' Length of walk in cell        : ',nsleep
        write(lu_sum,*)' Random seed value             : ',iseed 
        if(sobol)then
           write(lu_sum,*)' SAS Quasi-random sequence used'
        else
           write(lu_sum,*)' Pseudo-random sequence '
        end if
	if(istype.eq.1)then
           write(lu_sum,*)' Starting models read in from NAD file'
	else if(istype.eq.2)then
           write(lu_sum,*)' Starting models specified by user'
	else
           write(lu_sum,*)' Starting models generated randomly '
	end if
        write(lu_sum,100)
c
	if(summary)then

        write(lu_out,100)
        write(lu_out,fmt='("  Options set:"/)')
        if(monte)then
           write(lu_out,*)' process                       : ',
     &                    'Uniform Monte Carlo'
        else
           write(lu_out,*)' Process                       : ',
     &                    'Neighbourhood Algorithm'
        end if
        write(lu_out,*)' Initial sample size           : ',nsamplei
        write(lu_out,*)' Sample size                   : ',nsample
        write(lu_out,*)' Total number of iterations    : ',itmax
c       write(lu_out,*)' Number of axis samples        : ',naxis
c       write(lu_out,*)' Number of samples per reset   '
c       write(lu_out,*)' of distance database          : ',nclean
        write(lu_out,*)' Number of cells re-sampled    : ',ncells
        write(lu_out,*)' Total number of models        : ',ntotal
c       write(lu_out,*)' Length of walk in cell        : ',nsleep
        write(lu_out,*)' Random seed value             : ',iseed 
        if(sobol)then
           write(lu_out,*)' SAS Quasi-random sequence used'
        else
           write(lu_out,*)' Pseudo-random sequence used'
        end if
	if(istype.eq.1)then
           write(lu_out,*)' Starting models read in from NAD file'
	else if(istype.eq.2)then
           write(lu_out,*)' Starting models specified by user'
	else
           write(lu_out,*)' Starting models generated randomly '
	end if
        write(lu_out,100)

	end if

	end if
c

        if(verbose.and.lroot)then
	   open(lu_det,file='na.det',status='unknown')
           write(lu_det,100)
	   write(lu_det,*)' Details of each iteration'
           write(lu_det,100)
        end if

c
 100    format(/,72("-")/)
 200    format(/' Error in input options for NA'/)
 300    format(/3x,"Summary information of Neighbourhood",
     &             " algorithm performance")

        return
        end
c
c ----------------------------------------------------------------------------
c
c       NA_initialize - performs minor initialization tasks for NA algorithm.
c
c       Calls no other routines.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_initialize
     &             (range,ranget,scales,nd,nd_max,
     &              x,nsample,ncells,restartNA)
c
cifdef MPI
        include "mpif.h"
cendif
	real		range(2,nd)
	real		ranget(2,nd)
	real		scales(*)
        real		x(nd)
        real		rval(2)
c       real		psums(nsel_max+1)
        real            dummy(1)

	logical		restartNA
	logical		sobol
	logical		verbose
	logical		summary
	logical		timing
	logical		debug
	logical		lroot
 
        common /NA_MPI/iproc,nproc,lroot

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary
	common /NA_init/idnext,ic
        common/randomtype/sobol,iseed

c	common /NA_pickdata/psums(nsel_max+1),nfmax

	if(nd.gt.nd_max)then
	   write(*,400)nd,nd_max
           call na_abort
	end if   
          
c						set logical switch for 
c						first call to NA_sample 
c						(ensures distance list is
c						 initialized)
 	restartNA = .true.
c
c						set initial parameter
c						for NA walk
c	idnext = 1
 	ic = 1

	if(sobol)then
c                                               Initialize 1-D Sobol sequence
c						to control initial dimension 
c						in NA random walk
c          call sobseq(-2,rval)
           call sobseq(-1,rval)
c						Initialize pseudo-random 
c						number generator
	   iseed0 = iseed
	   a = ran3(iseed0)
c						open file for sas coefficients
c
	   if(lroot)open(lu_sob,file='sobol.coeff',status='unknown')

c						Generate coefficients
c						for quasi-random 
c						multi-dimensional SAS sequence
c
	   call NA_sas_table(nd*ncells,lu_sob)

cifdef MPI
c						need to sync here so that
c						all processes can read a
c						file in NA_sobol
          call MPI_BARRIER(MPI_COMM_WORLD)
cendif

	   if(lroot)close (lu_sob)
c                                               Initialize n-D Sobol sequence

	   open(lu_sob,file='sobol.coeff',status='unknown')

           call NA_sobol(lu_sob,nd*ncells,dummy,1,1)

	else
c						Initialize pseudo-random 
c						number generator
	   iseed0 = iseed
	   a = ran3(iseed)

	end if
c						Normalize parameter ranges
c						by a-priori model co-variances
c
        if(scales(1).eq.0.0)then
c						First option:
c						No transform 
c						(All a priori model 
c						 co-variances are 
c						 equal to unity)
	   do i=1,nd
              ranget(1,i) = range(1,i)
              ranget(2,i) = range(2,i)
	      scales(i+1) = 1.0
           end do

        else if(scales(1).eq.-1.0)then
c						Second option:
c						Use parameter range as
c						a priori model co-variances 
	   do i=1,nd
              ranget(1,i) = 0.0
              ranget(2,i) = 1.0
	      scales(i+1) = range(2,i)-range(1,i)
           end do

        else
c						Third option:
c						Use scales array as
c						a priori model co-variances 
	   do i=1,nd
              if(scales(i+1).eq.0.0)then
                 write(*,200)i
                 call na_abort
              end if
              ranget(1,i)  = 0.0
              ranget(2,i)  = (range(2,i)-range(1,i))/scales(i+1)
           end do

	end if
c						calculate axis increments
c                                               and initialize current point
c                                               (used by NA_sample) to
c                                               mid-point of parameter space

        do i=1,nd
           x(i) = (ranget(2,i)+ranget(1,i))/2.0
c          x(i) = 0.0
        end do
	
c						write out information
c						on parameter space
c						to summary file
	if(lu_sum.gt.5.and.lroot)then
	   
c       write(lu_sum,300)
	write(lu_sum,fmt='("Parameter space details:"/)')
        write(lu_sum,*)' Number of dimensions           : ',nd
        write(lu_sum,*)' '
        write(lu_sum,*)' Parameter ranges'
        write(lu_sum,*)'   Number   Minimum     Maximum   ',
     &                    ' A-prior cov Scaled min  Scaled max'
c
	do i=1,nd
           if(scales(1).eq.0.0)then
              sf = 1.0 
           else if(scales(1).eq.-1.0)then
              sf = range(2,i)-range(1,i)  
           else
              sf = scales(i+1)
           end if
           write(lu_sum,100)i,range(1,i),range(2,i),sf,
     &                      ranget(1,i),ranget(2,i)
	end do
        write(lu_sum,300)

	end if

 100    format(3x,i4,2x,5(f11.4,1x))
 200    format(/' Error in subroutine NA_initialize '//,
     &          ' Input a priori model co-variance is equal to zero',
     &          ' for parameter ',i4/
     &          ' This is not valid'//
     &          ' Remedy - check and adjust input',
     &          ' a priori co-variances'/)
 300    format(/72("-")/)
 400    format(/' Error in subroutine NA_initialize '//,
     &          ' Number of dimensions greater than maximum'/
     &          ' Number of dimensions needed  :',i4/
     &          ' Maximum number of dimensions :',i4//
     &          ' Remedy - increase parameter nd_max ',
     &          ' and recompile program'/)

	return
	end
c
c ----------------------------------------------------------------------------
c
c       NA_initial_sample - generates initial sample for NA algorithm.
c
c	Comments:
c
c		Assumes n-dimensional Sobol sequence has been initialized
c		Will generate a minimum of two samples.
c
c		Assumes ran3 has been initialized.
c
c       Calls no other routines.
c
c						M. Sambridge, Oct. 1996
c						(Updated for ran3 Aug. 1997)
c
c ----------------------------------------------------------------------------
c
	Subroutine NA_initial_sample
     &             (na_models,nd,range,rangeo,nsample,
     &              istype,monte,calcmovement,
     &              scales,misfit,run)

        include 'na_param.inc'

        real*4          na_models(nd,*)
        real*4          range(2,*)
        real*4          rangeo(2,*)
        real*4          scales(*)
        real*4          misfit(*)

        character       header*(nh_max)
        character*256   fnme
        character*5 run

        logical         sobol
        logical         verbose
	logical		summary
        logical         debug
        logical         timing
        logical         monte
        logical         calcmovement

        common/randomtype/sobol,iseed

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

c                                               read in starting
c                                               models from a NAD file
        if(istype.eq.1.and..not.monte)then

           fnme = run//'/NA/na.nad'
           call read_nad
     &          (lu_nad,fnme,nhi,nhui,iform,nd_nad,nsample,
     &           nh_max,nd_max,nmod_max,
     &           header,misfit,na_models)

           do i=1,nsample
              call transform2sca
     &             (na_models(1,i),nd,rangeo,scales,na_models(1,i))
           end do

        else if(istype.eq.2.and..not.monte)then

c						read in models from
c						ascii input file
c
	   open(lu_nad,file='models.in',status='old',err=33)
	   k = 1
 32	   read(lu_nad,*,end=34,err=33)
   	   read(lu_nad,*,err=33)misfit(k)
           read(lu_nad,*)(na_models(i,k),i=1,nd)
	   k = k + 1
           go to 32
 33        write(*,*)' Error reading input file models.in'
           call na_abort
 34        continue
	   close(lu_nad)
           nsample_r = k-1

c						scale models read in
           do i=1,nsample_r
              call transform2sca
     &             (na_models(1,i),nd,rangeo,scales,na_models(1,i))
           end do
c
	   if(nsample_r.lt.nsample)then
c						randomly generate the
c						the remaining samples 
	      nrem = nsample - nsample_r
	      write(*,*)' generating remaining samples ',nrem
c						Generate initial samples
c						using quasi random sequences
	      if(sobol)then
                 do i=nsample_r+1,nsample
                    do j=1,nd
                       call NA_sobol(ldummy,j,na_models(j,i),1,0)
                       a = na_models(j,i)
                       b = 1-a
                       na_models(j,i) = b*range(1,j) + a*range(2,j)
                    end do
                 end do
	      else
c						Use pseudo random 
c						number generator ran3 
                 do i=nsample_r+1,nsample
                    do j=1,nd
                       a = ran3(iseed)
                       b = 1-a
                       na_models(j,i) = b*range(1,j) + a*range(2,j)
                    end do
                 end do
	      end if

	   end if

	else
c						Generate initial uniform
c						random sample using a
c                                               uniform random distribution

c						Generate initial samples
c						using quasi random sequences
	   if(sobol)then
              do i=1,nsample
                 do j=1,nd
                    call NA_sobol(ldummy,j,na_models(j,i),1,0)
                    a = na_models(j,i)
                    b = 1-a
                    na_models(j,i) = b*range(1,j) + a*range(2,j)
                 end do
              end do

	   else
c						Use pseudo random 
c						number generator ran3 
              do i=1,nsample
                 do j=1,nd
                    a = ran3(iseed)
                    b = 1-a
                    na_models(j,i) = b*range(1,j) + a*range(2,j)
                 end do
              end do

	   end if

	end if

	return
	end
c
c ----------------------------------------------------------------------------
c
c       NA_random - generates a uniform random sample to be used
c		    instead of NA algorithm.
c
c	Assumes random number generator ran3 has been initialized
c
c       Calls ran3.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
	Subroutine NA_random
     &             (na_models,nd,range,ntot,nsample,calcmovement)

        real*4          na_models(nd,*),
     &                  range(2,*)

	logical		calcmovement
	logical		verbose
	logical		summary
	logical		timing
	logical		debug
	logical		sobol

        common /findnearestcom/dnear
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary
        common/randomtype/sobol,iseed


	dsum = 0.0
c						generate samples
        do i=ntot+1,ntot+nsample

	   if(sobol)then
c						use quasi-random
c						number generator
              do j=1,nd
                 call NA_sobol(ldummy,j,na_models(j,i),1,0)
                 a = na_models(j,i)
                 b = 1-a
                 na_models(j,i) = b*range(1,j) + a*range(2,j)
              end do
	   else
c						use pseudo-random
c						number generator
              do j=1,nd
                 a = ran3(iseed)
                 b = 1-a
                 na_models(j,i) = b*range(1,j) + a*range(2,j)
              end do
	   end if
c						find distance to 
c						nearest model
c						(for info purposes)

	   if(calcmovement)then

           call findnearest(na_models(1,i),na_models,i-1,nd,nnode)

           dsum = dsum + sqrt(dnear)

	   end if

        end do

c						write out average distance
c						of population from current
c						best model
	if(calcmovement)then
	   write(lu_dis,*)ntot+nsample,dsum/real(nsample)
        end if

	return
	end
c
c ----------------------------------------------------------------------------
c
c       NA_sas_table - uses a pseudo random number generator to
c		       build the initializing data for the quasi
c		       random SAS sequence.
c
c	Input:
c	nt			Number of sequences to be generated 
c	lu			A vacant logical unit for writing out
c				SAS initializing data to a file
c	Output:
c				table written to file sobol.coeff
c	
c	Comments:
c
c	This routine generates initializing data for multiple
c       Sobol-Antonov-Saleev quasi-random sequences. For each 
c	sequence a degree and order of the primitive polynomial 
c	are required, and here they are determined by a particular
c	formula (below).
c	
c	The degree, order and initializing random data for each SAS sequence, 
c	are written to a file, the free values have been generated 
c	randomly (under-constraints) using ran3 from Numerical Recipes. 
c	
c	For each degree and order pair (q,p) q initializing integers are 
c	required for each sequence, (M1, M2, ..., Mq), where
c	Mi may be any odd integer less than 2**i. So
c	for the i-th term, there are 2**(i-1) possible values. We write,
c	
c               Nq = 2**(i-1).
c	
c	Since each initializing datum is independent, the total number 
c	of possible sequences for degree q is the product,
c
c               Ntotal =  N1 x N2 x N3 x ... Nq,
c
c	which gives,
c
c               Ntotal = prod (for i=1,...,q) 2**(i-1),
c
c               Ntotal = 2**[sum(for i=1,...,q) (i-1))]
c
c               Ntotal = 2**(q*(q-1)/2)
c
c	Which gives,
c
c       q           Ntotal      Nq   Number of primitive polynomials (Np)
c       1                1       1            1
c       2                2       2            1
c       3                8       4            2
c       4               64       8            2
c       5             1024      16            6
c       6            32768      32            6
c       7          2097152      64           18
c       8        268435456     128           16
c       9     6.8719476E10     256           48
c      10     3.5184372E13     512           60
c
c
c	Note the number of possible primitive polynomial orders (Np)
c	and their values are defined the degree. 
c	All possible values of polynomial order for degrees up to 10 are
c	contained in the array pporder.
c	(A table can also be found on p 302 of Numerical Recipes in 
c	Fortran 2d Ed. Press et al 1992)
c	The product of Np and Ntotal is the total number of possible 
c 	sequences for that degree.
c
c	When generating a large number of independent sequences using randomly
c	generated initializing data it is prudent to use only higher degrees
c	because for, say degree 4 there are only 64 possible sequences for 
c	each of the two polynomial order values, and so
c	if more than 64 are generated some will be duplicates and hence
c	will produce identical (and not independent) sequences.
c
c	Array pporder contains all possible primitive polynomial orders
c	for each degree up to 10.
c
c	The particular formula used here to choose degree and polynomial
c	order for each independent sequence is to cycle through each degree
c	(starting from 5) and take ntotal/10 sequences from that degree.
c	Once the degree is chosen, the polynomial order cycles through
c	its possible values (given by array pporder). The objective here
c	is to minimize the likelihood of repeated trials with different
c	random seeds reproducing the same sequence. Remember there are 
c	a finite number of sequences for each degree (see above).
c
c       Calls ran3 and assumes that this pseudo random number generator 
c	has been initialized.
c
c						M. Sambridge, Aug. 1999
c
c ----------------------------------------------------------------------------
c
	Subroutine NA_sas_table(nt,lu)

        parameter(maxdeg=10)

        integer         a(maxdeg)
        real*8          ntot(10)
        integer		nprim(10)
        integer         pporder(60,10)
	logical		sobol

	logical		lroot

        common /NA_MPI/iproc,nproc,lroot

 	data		ntot/1.,2.,8.,64.,1024.,32768.,2097152.,
     &                       268435456.,6.8719476E10,3.5184372E13/
 	data		nprim/1,1,2,2,6,6,18,16,48,60/
 	data		pporder/0,59*0,
     &				1,59*0,
     &				1,2,58*0,
     &				1,4,58*0,
     &				2,4,7,11,13,14,54*0,
     &				1,13,16,19,22,25,54*0,
     &				1,4,7,8,14,19,21,28,31,32,
     &				37,41,42,50,55,56,59,62,42*0,
     &				14,21,22,38,47,49,50,52,56,67,
     &				70,84,97,103,115,122,44*0,
     &                          8,13,16,22,25,44,47,52,55,59,
     &				62,67,74,81,82,87,91,94,103,104,
     &				109,122,124,137,138,143,145,152,
     &				157,167,173,176,181,182,185,191,
     &				194,199,218,220,227,229,230,234,
     &				236,241,244,253,12*0,
     & 				4, 13, 19, 22, 50, 55, 64, 69, 
     &				98, 107, 115, 121, 127, 134, 140, 
     &				145, 152, 158, 161, 171, 181, 194, 
     &				199, 203, 208, 227, 242, 251, 253, 
     &				265, 266, 274, 283, 289, 295, 301, 
     &				316, 319, 324, 346, 352, 361, 367, 
     &				382, 395, 398, 400, 412, 419, 422, 
     &				426, 428, 433, 446, 454, 457, 472, 
     &				493, 505, 508/

        common/randomtype/sobol,iseed

	open(lu,file='sobol.coeff',status='unknown')

c	do i=1,10
c	   write(lu,*)(pporder(j,i),j=1,60)
c	end do
c       nt = 0
c       nl = 0
c       do i=1,19
c         read(10,*)
c       end do
c

        a(1) = 1
        if(lroot)write(lu,100)
        if(lroot)write(lu,101)nt
        if(lroot)write(lu,103)
        if(lroot)write(lu,102)iseed
c                                               choose degree, order and
c                                               number of independent
c                                               sequences to be generated
c						using malcolm's formula
c						defined above
        ii = 0
c          read(10,*)mdeg,ip,num
	do mdeg=5,10
           if(mdeg.gt.maxdeg)stop 'too many degrees'
	   numt = int(ntot(mdeg)/100)
	   do num=1,numt
	      is = mod(num,nprim(mdeg))+1
	      ip = pporder(is,mdeg) 
	      ii = ii + 1
              do j=2,mdeg
                 rval = ran3(iseed)
                 m = 2**(j-1)
                 a(j) = 2*(1+int(m*rval))-1
              end do
              if(lroot)
     &        write(lu,*)' ',mdeg,'   ',ip,'    ',(a(j),j=1,mdeg)
	      if(ii.eq.nt)go to 99
           end do
        end do
  99    continue
c
 100    format('% Initializing data for multi-dimensional',
     &             ' Sobol-Antonov-Saleev'/
     &             '% sequence generated randomly by routine ',
     &             'NA_sas_table'/
     &             '%'/'% The number of initializing values must be',
     &             ' equal to the degree '/
     &             '% and the i-th value is any',
     &             ' odd integer < 2**i'/'%')
 103    format('%'/
     &             '% Be careful not to generate too many sequences'/
     &             '% with low degree say < 5  because some may be'/
     &             '% identical due to the limited number of',
     &             ' possibilities'/'%'/
     &             '% The number of possible independent sequences',
     &             ' is defined by the table'/'%'/
     &             '% DEG : 1  2  3   4    5     6       7',
     &             '         8            9           10'/
     &             '% N   : 1  2  8  64 1024 32768 2097152 268435456',
     &             ' 6.8719476E10 3.5184372E13'/'%')

 101    format(1x,i8,12x,'maximum number of independent sequences')
 102    format('%',15x,'random seed used =',i10/
     &         '% deg   poly    Initializing values')

	close(lu)

	return
	end
c
c-----------------------------------------------------------------------
c
c	NA_sobol - Adaptation of numerical recipes routine for 
c		   generating a Sobol-Antonov-Saleev sequence 
c		   in n-dimensions.
c
c       Routine must be initialized by a first call with init = 1.
c       Initializing data is then read in from file `sobol.in' 
c	for each independent sequence. 
c
c       If mode = 0:
c       then an n-dimensional vector of independent quasi random deviates
c       is generated. The value of n should not be changed after
c       initialization.
c
c       If mode .ne. 0:
c       then n independent sequences are initialized
c       but each call generates the next value of the
c       nth-sequence, i.e. not all n are generated at once and different
c       numbers of deviates can be generated from each sequence. After
c       initialization n represents the sequence number for the next deviate
c       and may be any value between 1 and the n used for initialization.
c
c	Maximum number of random sequences read in from unclude file
c
c       The input parameter mode is used at initialization and must 
c	not be changed after initialization.
c
c					M. Sambridge, RSES, July 1998.
c
c-----------------------------------------------------------------------
c
      SUBROUTINE NA_sobol(lu,n,x,mode,init)
      INTEGER n,MAXBIT,MAXSEQ
      REAL x(*)
c
      include	'na_param.inc'
c
c     PARAMETER (MAXBIT=30,MAXSEQ=160)
      PARAMETER (MAXBIT=30)
      INTEGER i,im,in,ipp,j,k,l,ip(MAXSEQ),iu(MAXSEQ,MAXBIT),iv(MAXBIT*
     *MAXSEQ),ix(MAXSEQ),mdeg(MAXSEQ),inn(MAXSEQ)
      REAL fac
      SAVE ip,mdeg,ix,iv,in,fac,inn
      EQUIVALENCE (iv,iu)
c
      common/nab_IO/silent,verbose,debug
      logical		debug
      logical		verbose
      logical		silent

      if (init.eq.1) then
c                                               read in data
        do i=1,6
          read(lu,*)
        end do
        read(lu,*)nn
        do i=1,12
          read(lu,*)
        end do
        if(n.gt.MAXSEQ)then
           write(*,*)
           write(*,*)' Error in subroutine NA_sobol'
           write(*,*)' Too many random sequences required'
           write(*,*)' Current maximum dimension ',MAXSEQ
           write(*,*)' Number requested          ',n
           write(*,*)
           write(*,*)' Remedy: increase parameter MAXSEQ'
           write(*,*)'         and recompile'
           write(*,*)
           call na_abort
        end if
        if(n.gt.nn)then
           write(*,*)
           write(*,*)' Error in subroutine NA_sobol'
           write(*,*)' Not enough initializing data in input file'
           write(*,*)' Number of sequences in data file       ',nn
           write(*,*)' Number requested                       ',n
           write(*,*)
           write(*,*)' Remedy: Initializing data is generated'
           write(*,*)'         automatically so there must be a bug'
           write(*,*)'         somewhere. Contact an expert quickly.'
           write(*,*)
           call na_abort
        end if
        do i=1,n
           read(lu,*)mdeg(i),ip(i),(iu(i,j),j=1,mdeg(i))
        end do
	if(debug)then
	   write(*,*)' NA_sobol read in initializing data for',
     &               n,' quasi-random sequences' 
	end if

        do i=1,MAXSEQ
           ix(i) = 0
        end do

        do 14 k=1,MAXSEQ
          do 11 j=1,mdeg(k)
            iu(k,j)=iu(k,j)*2**(MAXBIT-j)
11        continue
          do 13 j=mdeg(k)+1,MAXBIT
            ipp=ip(k)
            i=iu(k,j-mdeg(k))
            i=ieor(i,i/2**mdeg(k))
            do 12 l=mdeg(k)-1,1,-1
              if(iand(ipp,1).ne.0)i=ieor(i,iu(k,j-l))
              ipp=ipp/2
12          continue
            iu(k,j)=i
13        continue
14      continue
        fac=1./2.**MAXBIT

        if(mode.eq.0)then
          in=0
        else
          do i=1,n
           inn(i) = 0
          end do
        end if

      else

c                                       generate n-dimensional
c                                       quasi-deviate
        if(mode.eq.0)then

           im=in
           do 15 j=1,MAXBIT
             if(iand(im,1).eq.0)goto 1
             im=im/2
15         continue
           stop 'MAXBIT too small in sobol'
1          im=(j-1)*MAXSEQ
           do 16 k=1,min(n,MAXSEQ)
             ix(k)=ieor(ix(k),iv(im+k))
             x(k)=ix(k)*fac
16         continue
           in=in+1

        else
c                                       generate next quasi
c                                       deviate in n-th sequence
           im=inn(n)
           do 115 j=1,MAXBIT
             if(iand(im,1).eq.0)goto 100
             im=im/2
115        continue
           stop 'MAXBIT too small in sobol'
100        im=(j-1)*MAXSEQ
c          do 16 k=1,min(n,MAXSEQ)
             ix(n)=ieor(ix(n),iv(im+n))
c            x(n)=ix(n)*fac
             x(1)=ix(n)*fac
c16        continue
           inn(n)=inn(n)+1

c	   write(50,*)n,x(1) 

        end if

      endif

      return
      END
c
c ----------------------------------------------------------------------------
c
c       NA_misfits - calculate performance statistics for NA algorithm.
c
c       Calls no other routines.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
	Subroutine NA_misfits
     &             (misfit,nsample,it,ntot,mfitmin,
     &              mfitminc,mfitmean,mopt,
     &		    ncells,work,ind,iwork,mfitord)

	real		misfit(*)
	real		mfitmin
	real		mfitmean
	real		mfitminc
	real		work(*)

	integer		ind(*)
	integer		mfitord(*)
	integer		iwork(*)

	logical		verbose
	logical		summary
	logical		timing
	logical		debug

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

        mfitminc = misfit(ntot+1)
        mfitmean = mfitminc
        iopt = ntot+1

	do i=ntot+2,ntot+nsample
           mfitmean = mfitmean + misfit(i)
           if(misfit(i).lt.mfitminc)then
              mfitminc = misfit(i)
	      iopt = i
           end if 
	end do
        mfitmean = mfitmean/real(nsample)

        if(mfitminc.lt.mfitmin.or.it.eq.1)then
           mopt = iopt
           mfitmin = mfitminc
        end if

c					find mtop lowest misfits
c       write(*,*)' it       = ',it
c       write(*,*)' ntot     = ',ntot
c       write(*,*)' mfitmin  = ',mfitmin
c       write(*,*)' mfitmean = ',mfitmean
c       write(*,*)' mfitminc = ',mfitminc

c                                       find models with
c                                       lowest ncells misfit values
	   if(ncells.eq.1)then

               mfitord(1) = mopt

           else 

	      ntotal = ntot+nsample
              do i=1,ntotal
	         ind(i) = i
                 work(i) = misfit(i)
              end do
   
c							jumble initial indices
c							to randomize order
c							of models when misfits
c							are equal
     	      call jumble(ind,work,ntotal)
c
              flow = select(ncells,ntotal,work,ind,iselect)

c	      write(88,*)' flow = ',flow
c	      write(88,*)' iselect = ',iselect
c	      write(88,*)' ncells = ',ncells
c             do j=1,ntotal
c                write(88,*)' j',j,' misfit ',work(j),
c    &                     misfit(j),' ind ',ind(j)
c             end do

	      do j=1,ncells
                iwork(j) = ind(j)
              end do 
c					order misfit of lowest ncells
c
              call indexx(ncells,work,ind)

 	      do j=1,ncells
                 mfitord(j) = iwork(ind(j))
c 		 write(88,*)' mfitord ',j,mfitord(j),misfit(mfitord(j))
              end do
c
c	      do j=1,ncells
c                k = mfitord(j)
c                write(88,*)' sorted model ',k,' misfit ',misfit(k)
c             end do

	   end if

	return
	end
c
c---------------------------------------------------------------------------
c
c     NA_deviate - generates a random deviate according to
c                  a given distribution using a 1-D SAS sequence.
c		   or a pseudo-random sequence depending of logical
c		   `sobol'
c
c     Comments:
c		If sobol = .true.: (Quasi-random number)
c
c		   This routine generates a random number 
c		   between x1 and x2.
c		   The parameter i is the sequence number from 
c		   which the quasi random devaite is drawn.
c
c		If sobol = .false. (Pseduo-random number)
c
c		   ran3 is called to calculate a deviate which is
c		   scaled to the input boundaries x1,x2.
c
c		This version is for resample mode and simply generates
c		a deviate between input values x1 and x2.
c
c	        calls NA_sobol
c
c---------------------------------------------------------------------------
c
        Subroutine NA_deviate
     &             (x1,x2,i,deviate)
c
        logical         sobol
        real            ran(1)
 
        common/randomtype/sobol,iseed
c							Use SAS sequence
	if(sobol)then

           call NA_sobol(ldummy,i,ran,1,0)
           deviate = x1 + (x2-x1)*ran(1)

c	   write(50,*)' n ',n,' i',i,' j',j,' dev ',dev(i,j)

	else

	   ran = ran3(iseed)
           deviate = x1 + (x2-x1)*ran(1)

	end if

        return
        end
c
c---------------------------------------------------------------------------
c
c     NA_gen_deviates - generates uniform quasi random deviates using
c                       a Multi-dimensional Sobol-Antonov-Saleev sequence.
c
c       Input:
c	      n 		: Number of independent sequences to 
c				: be generated (one per dimension) 
c	      m 		: Number of terms in each sequence
c				: to be generated.
c       Output:
c	      dev(n,m))		: Array of deviates.
c	
c     Comments:
c		Generates all deviates required for one execution of
c		routine NA_sample and stores them in array dev. This is
c	        necessary because of the order the deviates are used
c		in NA_sample is different from that in which they 
c		can be generated. In this way it is possible to use
c	        independent multi-dimensional SAS sequences in each
c		resampled cell. Without this `in advance' approach the
c		same SAS sequence would need to be used across more
c		than one cell which introduces undesirable cyclicity in
c		the use of the samples from a single sequence.
c
c---------------------------------------------------------------------------
c
        Subroutine NA_gen_deviates 
     &       			  (nd,nc,nsp,nsl,nsample,dev)

        real            dev(nd*nc,*)
        logical         sobol

        common/randomtype/sobol,iseed
 
	nrem = mod(nsample,nc)

	n = nd*nc
	m = nsp*nsl
	n1 = nd*nrem
	n2 = nd*(nc-nrem)
	m1 = nsp*nsl
	m2 = (nsp-1)*nsl

	if(sobol)then

	  if(nrem.eq.0)then
	     do i=1,m
	        do j=1,n
                   call NA_sobol(ldummy,j,dev(j,i),1,0)
                end do
             end do
	  else
	     do i=1,m1
	        do j=1,n1
                   call NA_sobol(ldummy,j,dev(j,i),1,0)
                end do
             end do
	     do i=1,m2
	        do j=n1+1,n
                   call NA_sobol(ldummy,j,dev(j,i),1,0)
                end do
             end do
	  end if
	end if

c	write(50,*)' gen deviates'
c	do j=1,n
c	   write(50,*)j,' :',(dev(j,i),i=1,m)
c	end do
c	write(50,*)

	return
	end
c
c ----------------------------------------------------------------------------
c
c       NA_sample - generates a new sample of models using 
c                   the Neighbourhood algorithm by distributing
c		    nsample new models in ncells cells.
c
c	Comments:
c		 If xcur is changed between calls then restartNA 
c		 must be set to true. logical restartNA must also 
c		 be set to true on the first call.
c
c       Calls are made to various NA_routines.
c
c						M. Sambridge
c						Last updated Sept. 1999.
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_sample
     &             (na_models, ntot, nsample, nd, nsleep, ncells,
     &              misfit, mfitord, range, 
     &              check, xcur, restartNA, 
     &              calcmovement, nclean, dlist)

	real		na_models(nd,*)
	real		range(2,*)
	real		misfit(*)

	real		xcur(*)
	real		dlist(*)
        real		xdum(100)
c
c       integer		order(ntot,nd)
c       integer		rank(ntot,nd)
c       integer		nodes(nnaxis_max)
c	integer		iwork1(nmod_max)
c       integer		nanodes(nmod_max)
c	real		danodes(nnaxis_max)
c	real		x(nnaxis_max)
c	real		del(nd_max)
c

        integer		mfitord(*)
	integer		cell

	logical		verbose
	logical		summary
	logical		timing
	logical		debug
	logical		resetlist
	logical		check
	logical		restartNA
	logical		info
c	logical		x_on_left
c	logical		x_on_right
	logical		calcmovement

        common /NA_info/nxsave,ndsave,ndc,nerr,ncald,nupd,
     &                  cells,torder,taxis,tup,tcd,tdev,tna,tres

	common /NA_info_special/taxis2

	common /NA_init/idnext,ic

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

	save id

c	write(*,*)' inside NA_sample'
c	write(*,*)' ntot',ntot
c	write(*,*)' nsample',nsample
c	write(*,*)' nd',nd
c	write(*,*)' naxis',naxis
c	write(*,*)' xcur',(xcur(ii),ii=1,nd)

c                                               choose initial 
c                                               axis randomly
        call irandomvalue(1,nd,idnext)
c
c						initialize some variables
	ic = ic + 1
        info = .false.
        if(mod(ic,nclean).eq.0)resetlist = .true.
 	if(mod(ic,nclean).eq.0.and.verbose)info = .true.
        if(timing)t1 = cputime(t2,t3)
        idiff = 0
        ndc = 0
        cells = 0.0
        nxsave = 0
        ndsave = 0
        nerr = 0
        taxis = 0.0
        taxis2 = 0.0
        tup = 0.0
        tna = 0.0
        tcd = 0.0
        tdev = 0.0
        tres = 0.0
        cell = 1
        mopt = mfitord(cell)
        ind_cellnext = mopt
        ind_celllast = 0
	dsum = 0.0
	dcount = 0.0
	nrem = mod(nsample,ncells)
        if(nrem.eq.0)then
           nsampercell = nsample/ncells
	else
           nsampercell = 1+nsample/ncells
	end if

        icount = 0
 	if(debug)write(*,*)' nsample     = ',nsample
 	if(debug)write(*,*)' nsampercell = ',nsampercell
	if(debug)write(*,*)' ncells      = ',ncells
c       write(lu_sum,*)
c       write(lu_sum,*)
c
c						loop over samples
        do is = 1,nsample
c						choose Voronoi cell 
c						for sampling
	   ind_cell = ind_cellnext 
           icount = icount + 1
 	   if(debug)write(*,*)cell,' cell = ',ind_cell
           if(ind_cell.ne.ind_celllast)then

              if(timing)then
                t1 = cputime(t2,t3)
                tna = tna + t2
              end if 
c						reset walk to 
c						chosen model
              call NA_restart
     &             (na_models,nd,ind_cell,xcur,debug,restartNA)

c	      write(lu_sum,*)' generating ',nsampercell,
c    &        ' samples in cell ',ind_cell,' misfit ',misfit(ind_cell)

              if(timing)then
                t1 = cputime(t2,t3)
                tres = tres + t2
                tna = tna + t2
              end if 
	   end if

           if(restartNA)then
              resetlist = .true.
              restartNA = .false.
           end if
c
c          write(100,*)' is',is
c          write(100,*)' nodex',nodex
c          write(100,*)(xcur(ii),ii=1,nd)

c						loop over walk steps
           do il = 1,nsleep
           do iw = 1,nd

c             write(*,*)' is',is,' iw ',iw,' id ',id,' idnext',idnext
c             write(*,*)' restartNA',restartNA
c             write(*,*)' resetlist',resetlist
c
c						update dlist and nodex
c						for new axis

              if(.not.resetlist)then
c                write(*,*)' updated dlist '
                 if(timing)then
                    t1 = cputime(t2,t3)
                    tna = tna + t2
                 end if
c                                               incremental update
                 call NNupdate_dlist
     &                (idnext,id,dlist,na_models,
     &                 nd,ntot,xcur,nodex,dminx)

                 if(timing)then
                    t1 = cputime(t2,t3)
                    tup = tup + t2
                    tna = tna + t2
                 end if
                 nupd = nupd + 1
              else
c                write(*,*)' resetting dlist '

                 if(timing)then
                    t1 = cputime(t2,t3)
                    tna = tna + t2
                 end if
c                                               full update
                 call NNcalc_dlist
     &                (idnext,dlist,na_models,
     &                 nd,ntot,xcur,nodex,dminx)

                 if(timing)then
                    t1 = cputime(t2,t3)
                    tcd = tcd + t2
                    tna = tna + t2
                 end if
                 ncald = ncald + 1
                 resetlist = .false.

              end if

              id = idnext

              if(timing)then
                 t1 = cputime(t2,t3)
                 tna = tna + t2
              end if
c						Calculate intersection
c						of current Voronoi cell 
c						with current 1-D axis
c
              call NNaxis_intersect
     &             (xcur,id,dlist,na_models,nd,ntot,
     &              nodex,range(1,id),range(2,id),x1,x2)

              if(timing)then
                 t1 = cputime(t2,t3)
                 tna = tna + t2
                 taxis = taxis + t2
              end if

c	      small = 1.oE-7
c	      call checkNNaxis_intersect
c    &             (naxis,ntot,na_models,nd,xcur,x,
c    &              id,is,iw,nerr,small,.true.,nodex,x1,x2)

c
c						Generate new node in 
c						Voronoi cell of input point
              if(timing)then
                 t1 = cputime(t2,t3)
                 tna = tna + t2
              end if

              kd = id + (cell-1)*nd
              call NA_deviate (x1,x2,kd,xcur(id))

              if(timing)then
                 t1 = cputime(t2,t3)
                 tdev = tdev + t2
                 tna = tna + t2
              end if

c             nxsave = nxsave + nxs
c             ndsave = ndsave + nds

c						check Voronoi boundaries 

 	      if(check)then
                 do i=1,nd
                   xdum(i) = xcur(i)
                 end do
                 xdum(id) = x1
	         call findnearest(xdum,na_models,ntot,nd,nnode)
	         write(*,*)' Nearest node to x1 = ',nnode
                 xdum(id) = x2
	         call findnearest(xdum,na_models,ntot,nd,nnode)
	         write(lu_sum,*)' Nearest node to x2 = ',nnode
	         write(*,*)' Nearest node to x2 = ',nnode
 	      end if
c
c						increment axis 
              idnext = idnext + 1
              if(idnext.gt.nd)idnext=1
c
c             write(*,*)' new sample '
c             write(*,*)' id ',id
c             write(*,*)' xcur ',xcur(id)

           end do
           end do
c						put new sample in list
           j = ntot+is
           do i=1,nd
              na_models(i,j) = xcur(i)
           end do
c						check nearest node

	   if(check)then
	      call findnearest(xcur,na_models,ntot,nd,nnode)

 	      write(lu_sum,*)' Nearest node to new model',is+ntot,
     &                       ' = ',nnode
 	      write(*,*)' Nearest node to new model',is+ntot,
     &                  ' = ',nnode
              if(nnode.ne.nodex)then
                 write(lu_sum,100)nodex,nnode,is+ntot,iw,id
                 write(*,100)nodex,nnode,is+ntot,iw,id
	      end if
	   end if

c						find distance moved 
c						from Vcell node 

	   if(calcmovement.and.ind_cell.eq.mopt)then
              dist = 0.0
              do i=1,nd
                dd = (na_models(i,nodex) - xcur(i))
                dd = dd*dd
                dist = dist + dd
              end do
              dsum = dsum + sqrt(dist)
              dcount = dcount + 1
           end if

	   ind_celllast = ind_cell

           if(icount.eq.nsampercell)then
              icount = 0 
              cell = cell + 1
	      ind_cellnext = mfitord(cell)
	      if(cell.eq.nrem+1)nsampercell = nsampercell - 1
           end if
c

c          write(100,*)' new sample '
c          write(100,*)' nodex ',nodex
c          write(100,*)(xcur(ii),ii=1,nd)

        end do
c						write average distance
c						of samples from node 
c						in optimum Vcell 
	if(calcmovement)then
           write(lu_dis,*)ntot+nsample,dsum/dcount,ind_cell
	end if
c						write out average distance
c						of samples from current Vcell
c						node
c	write(*,*)' xcur on exit '
c	write(*,*)' xcur',(xcur(ii),ii=1,nd)
c	write(*,*)' finished NA_sample'

        if(timing)then
           t1 = cputime(t2,t3)
           tna = tna + t2
        end if
        if(info)cells = idiff/(real(nd*nsample))

c       write(*,*)'Number of x saves in generating sample ',nxsave
c       write(*,*)'Number of d saves in generating sample ',ndsave
c       write(*,*)'Number of distance calculations',ndc
c       write(*,*)'Average number of cells encountered per axis',cells
c       write(*,*)'Total time for NNorder',torder
c       write(*,*)'Total time for NNaxis',taxis

 100    format(1x,' WARNING node no longer in original Voronoi cell:'/
     &         ,' original cell =',i7/
     &         ,'      new cell =',i7/
     &         ,'            is =',i7/
     &         ,'            iw =',i7/
     &         ,'            id =',i7/
     &         ,'         nodes :')
 101   format(1x,10(1x,i6))

 	return
 	end	
c
c-----------------------------------------------------------------------
c
c	NNaxis_intersect - find intersections of current Voronoi cell 
c			   with current 1-D axis.
c
c       Input:
c	      x(nd)		:point on axis
c	      dim		:dimension index (defines axis)
c	      dlist		:set of distances of base points to axis 
c	      bp(nd,nb)		:set of base points
c	      nd		:number of dimensions
c	      nb		:number of base points 
c	      resetlist		:TRUE if dlist and nodex is to be calculated
c	      nodex		:index of base node closest to x
c	      dmin_in		:distance of base node closest to x
c	      xmin		:start point along axis
c	      xmax		:end point along axis
c
c       Output:
c	      x1		:intersection of first Voronoi boundary 
c	      x2		:intersection of second Voronoi boundary 
c
c       Comment:
c	        This method uses a simple formula to exactly calculate
c		the intersections of the Voronoi cells with the 1-D axis.
c		It makes use of the perpendicluar distances of all nodes
c		to the current axis contained in the array dlist. 
c
c	        The method involves a loop over ensemble nodes for 
c		each new intersection found. For an axis intersected
c		by ni Voronoi cells the run time is proportional to ni*ne.
c
c		It is assumed that the input point x(nd) lies in
c		the Vcell of nodex, i.e. nodex is the closest node to x(nd).
c
c		Note: If the intersection points are outside of either
c		      axis range then the axis range is returned, i.e.
c
c		      		x1 is set to max(x1,xmin) and  
c		      		x2 is set to min(x2,xmin) and  
c
c                                       M. Sambridge, RSES, June 1998
c
c-----------------------------------------------------------------------
c
 	Subroutine NNaxis_intersect
     &             (x,dim,dlist,bp,nd,nb,
     &              nodex,xmin,xmax,x1,x2)

	real*4		x(nd)
	real*4		bp(nd,nb)
	real*4		dlist(nb)
        integer		dim
c						search through nodes
	   x1 = xmin
	   x2 = xmax
  	   dp0   = dlist(nodex)
	   x0    = bp(dim,nodex)

c	   write(*,*)
c	   write(*,*)'k ',k,' xmin ',xmin,' xmax ',xmax,' x0',x0
c	   write(*,*)'node0 = ',node0
c	   write(*,*)'left = ',left
c	   write(*,*)'right = ',right
c						find intersection of current 
c						Voronoi cell with 1-D axis
           do j=1,nodex-1
              xc    = bp(dim,j)
              dpc   = dlist(j)
c						calculate intersection of
c						interface (between nodes 
c						nodex and j) and 1-D axis.
	      dx = x0 - xc
	      if(dx.ne.0.0)then
	         xi = 0.5*(x0+xc+(dp0-dpc)/dx)
                 if(xi.gt.xmin.and.xi.lt.xmax)then
                    if(xi.gt.x1.and.x0.gt.xc)then
                       x1 = xi
                    else if(xi.lt.x2.and.x0.lt.xc)then
                       x2 = xi
	            end if
	         end if
	      end if
	   end do

           do j=nodex+1,nb
              xc    = bp(dim,j)
              dpc   = dlist(j)
c						calculate intersection of
c						interface (between nodes 
c						nodex and j) and 1-D axis.
	      dx = x0 - xc
	      if(dx.ne.0.0)then
	         xi = 0.5*(x0+xc+(dp0-dpc)/dx)
                 if(xi.gt.xmin.and.xi.lt.xmax)then
                    if(xi.gt.x1.and.x0.gt.xc)then
                       x1 = xi
                    else if(xi.lt.x2.and.x0.lt.xc)then
                       x2 = xi
	            end if
	         end if
	      end if
	   end do

	return
	end
c
c ----------------------------------------------------------------------------
c
c       NA_restart - resets NA walk to start from input model.
c
c       Calls no other routines.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_restart
     &             (na_models,nd,mreset,x,debug,restartNA)

	real		na_models(nd,*)
	real		x(*)

	logical		restartNA
	logical		debug
c
	if(debug)then
           write(*,*)' NA_restart: reset to model ',mreset
           write(*,*)' current model on entry '
           write(*,*)(x(k),k=1,nd)
        end if

	do i=1,nd
          x(i) = na_models(i,mreset)
        end do

	restartNA = .true.

	if(debug)then
           write(*,*)' current model on exit '
           write(*,*)(x(k),k=1,nd)
        end if

	return
	end
c
c-----------------------------------------------------------------------
c
c       Subroutine NNcalc_dlist - calculates square of distance from
c                                 all base points to new axis (defined
c                                 by dimension dim through point x.
c                                 It also updates the nearest node and
c                                 distance to the point x.
c
c       This is a full update of dlist, i.e. not using a previous dlist.
c
c-----------------------------------------------------------------------
c
        Subroutine NNcalc_dlist
     &             (dim,dlist,bp,nd,nb,x,nodex,dminx)

        real*4          bp(nd,*)
        real*4          x(nd)
        real*4          dlist(*)
        integer         dim

           dmin = 0.
           do j=1,dim-1
              d = (x(j)-bp(j,1))
              d = d*d
              dmin = dmin + d
           end do
           do j=dim+1,nd
              d = (x(j)-bp(j,1))
              d = d*d
              dmin = dmin + d
           end do
           dlist(1) = dmin
           d = (x(dim)-bp(dim,1))
           d = d*d
           dmin = dmin + d
           nodex = 1
c
           do i=2,nb
              dsum = 0.
              do j=1,dim-1
                 d = (x(j)-bp(j,i))
                 d = d*d
                 dsum = dsum + d
              end do
              do j=dim+1,nd
                 d = (x(j)-bp(j,i))
                 d = d*d
                 dsum = dsum + d
              end do
              dlist(i) = dsum
              d = (x(dim)-bp(dim,i))
              d = d*d
              dsum = dsum + d
              if(dmin.gt.dsum)then
                 dmin = dsum
                 nodex = i
              end if
              dnodex = dmin
           end do

c          write(*,*)' resetlist'
c          write(*,*)' dlist',(dlist(i),i=1,nb)
c          write(*,*)' input nodex',nodex

        return
        end


c
c-----------------------------------------------------------------------
c
c	Subroutine NNupdate_dlist - calculates square of distance from 
c				     all base points to new axis, assuming
c                                    dlist contains square of all distances 
c				     to previous axis dimlast. It also
c				     updates the nearest node to the
c				     point x through which the axes pass.
c				
c
c-----------------------------------------------------------------------
c
	Subroutine NNupdate_dlist
     &             (dim,dimlast,dlist,bp,nd,nb,x,node,dmin)

	real*4		bp(nd,*)
	real*4		x(nd)
	real*4		dlist(*)
        integer		dim,dimlast

        d1 = (x(dimlast)-bp(dimlast,1))
        d1 = d1*d1
        dmin = dlist(1)+d1
        node = 1
        d2 = (x(dim)-bp(dim,1))
        d2 = d2*d2
        dlist(1) = dmin-d2
	do i=2,nb
           d1 = (x(dimlast)-bp(dimlast,i))
           ds = d1
           d1 = dlist(i)+d1*d1
           if(dmin.gt.d1)then
              dmin = d1
              node = i
           end if
           d2 = (x(dim)-bp(dim,i))
           d2 = d2*d2
           dlist(i) = d1-d2
c          if(i.eq.nb)then
c             write(*,*)' NNupdate_dlist: node 20'
c             write(*,*)' dlist ',dlist(i)
c             write(*,*)' dim ',dim
c             write(*,*)' dimlast ',dimlast
c             write(*,*)' x ',x(1),x(2)
c             write(*,*)' bp ',bp(1,20),bp(2,20)
c             write(*,*)' d1 ',ds
c             write(*,*)' d2 ',d2
c          end if

        end do

	return
	end
c-----------------------------------------------------------------------
c
c	Numerical recipes routine
c
c-----------------------------------------------------------------------
c
      SUBROUTINE indexx(n,arr,indx)
      INTEGER n,indx(n),M,NSTACK
      REAL arr(n)
      PARAMETER (M=7,NSTACK=50)
      INTEGER i,indxt,ir,itemp,j,jstack,k,l,istack(NSTACK)
      REAL a
      do 11 j=1,n
        indx(j)=j
11    continue
      jstack=0
      l=1
      ir=n
1     if(ir-l.lt.M)then
        do 13 j=l+1,ir
          indxt=indx(j)
          a=arr(indxt)
          do 12 i=j-1,1,-1
            if(arr(indx(i)).le.a)goto 2
            indx(i+1)=indx(i)
12        continue
          i=0
2         indx(i+1)=indxt
13      continue
        if(jstack.eq.0)return
        ir=istack(jstack)
        l=istack(jstack-1)
        jstack=jstack-2
      else
        k=(l+ir)/2
        itemp=indx(k)
        indx(k)=indx(l+1)
        indx(l+1)=itemp
        if(arr(indx(l+1)).gt.arr(indx(ir)))then
          itemp=indx(l+1)
          indx(l+1)=indx(ir)
          indx(ir)=itemp
        endif
        if(arr(indx(l)).gt.arr(indx(ir)))then
          itemp=indx(l)
          indx(l)=indx(ir)
          indx(ir)=itemp
        endif
        if(arr(indx(l+1)).gt.arr(indx(l)))then
          itemp=indx(l+1)
          indx(l+1)=indx(l)
          indx(l)=itemp
        endif
        i=l+1
        j=ir
        indxt=indx(l)
        a=arr(indxt)
3       continue
          i=i+1
        if(arr(indx(i)).lt.a)goto 3
4       continue
          j=j-1
        if(arr(indx(j)).gt.a)goto 4
        if(j.lt.i)goto 5
        itemp=indx(i)
        indx(i)=indx(j)
        indx(j)=itemp
        goto 3
5       indx(l)=indx(j)
        indx(j)=indxt
        jstack=jstack+2
        if(jstack.gt.NSTACK)stop 'NSTACK too small in indexx'
        if(ir-i+1.ge.j-l)then
          istack(jstack)=ir
          istack(jstack-1)=i
          ir=j-1
        else
          istack(jstack)=j-1
          istack(jstack-1)=l
          l=i
        endif
      endif
      goto 1
      END
c
c ----------------------------------------------------------------------------
c						
c	Numerical Recipes random number generator (used by NA_random)
c
c ----------------------------------------------------------------------------
      FUNCTION ran3(idum)
      INTEGER idum
      INTEGER MBIG,MSEED,MZ
C     REAL MBIG,MSEED,MZ
      REAL ran3,FAC
      PARAMETER (MBIG=1000000000,MSEED=161803398,MZ=0,FAC=1./MBIG)
C     PARAMETER (MBIG=4000000.,MSEED=1618033.,MZ=0.,FAC=1./MBIG)
      INTEGER i,iff,ii,inext,inextp,k
      INTEGER mj,mk,ma(55)
C     REAL mj,mk,ma(55)
      SAVE iff,inext,inextp,ma
      DATA iff /0/
c MOD Jean 31/10/08
      call random_number (ran3)
      return
c end MOD Jean
      if(idum.lt.0.or.iff.eq.0)then
        iff=1
        mj=MSEED-iabs(idum)
        mj=mod(mj,MBIG)
        ma(55)=mj
        mk=1
        do 11 i=1,54
          ii=mod(21*i,55)
          ma(ii)=mk
          mk=mj-mk
          if(mk.lt.MZ)mk=mk+MBIG
          mj=ma(ii)
11      continue
        do 13 k=1,4
          do 12 i=1,55
            ma(i)=ma(i)-ma(1+mod(i+30,55))
            if(ma(i).lt.MZ)ma(i)=ma(i)+MBIG
12        continue
13      continue
        inext=0
        inextp=31
        idum=1
      endif
      inext=inext+1
      if(inext.eq.56)inext=1
      inextp=inextp+1
      if(inextp.eq.56)inextp=1
      mj=ma(inext)-ma(inextp)
      if(mj.lt.MZ)mj=mj+MBIG
      ma(inext)=mj
      ran3=mj*FAC
      return
      END
c
c-----------------------------------------------------------------------
c
c	Numerical recipes routine
c
c-----------------------------------------------------------------------
c
      SUBROUTINE sobseq(n,x)
      INTEGER n,MAXBIT,MAXDIM
      REAL x(*)
      PARAMETER (MAXBIT=30,MAXDIM=6)
      INTEGER i,im,in,ipp,j,k,l,ip(MAXDIM),iu(MAXDIM,MAXBIT),iv(MAXBIT*
     *MAXDIM),ix(MAXDIM),mdeg(MAXDIM)
      REAL fac
      SAVE ip,mdeg,ix,iv,in,fac
      EQUIVALENCE (iv,iu)
      DATA ip /0,1,1,2,1,4/, mdeg /1,2,3,3,4,4/, ix /6*0/
      DATA iv /6*1,3,1,3,3,1,1,5,7,7,3,3,5,15,11,5,15,13,9,156*0/
      if (n.lt.0) then
        do 14 k=1,MAXDIM
          do 11 j=1,mdeg(k)
            iu(k,j)=iu(k,j)*2**(MAXBIT-j)
11        continue
          do 13 j=mdeg(k)+1,MAXBIT
            ipp=ip(k)
            i=iu(k,j-mdeg(k))
            i=ieor(i,i/2**mdeg(k))
            do 12 l=mdeg(k)-1,1,-1
              if(iand(ipp,1).ne.0)i=ieor(i,iu(k,j-l))
              ipp=ipp/2
12          continue
            iu(k,j)=i
13        continue
14      continue
        fac=1./2.**MAXBIT
        in=0
      else
        im=in
        do 15 j=1,MAXBIT
          if(iand(im,1).eq.0)goto 1
          im=im/2
15      continue
        stop 'MAXBIT too small in sobseq'
1       im=(j-1)*MAXDIM
        do 16 k=1,min(n,MAXDIM)
          ix(k)=ieor(ix(k),iv(im+k))
          x(k)=ix(k)*fac
16      continue
        in=in+1
      endif
      return
      END
c
c-----------------------------------------------------------------------
c
c	Numerical recipes routine adapted to give ind and iselect
c
c-----------------------------------------------------------------------
c
      FUNCTION select(k,n,arr,ind,iselect)
      INTEGER k,n
      REAL select,arr(n)
      integer ind(n)
      INTEGER i,ir,j,l,mid
      REAL a,temp
      l=1
      ir=n
1     if(ir-l.le.1)then
        if(ir-l.eq.1)then
          if(arr(ir).lt.arr(l))then
            temp=arr(l)
            arr(l)=arr(ir)
            arr(ir)=temp
            itemp=ind(l)
            ind(l)=ind(ir)
            ind(ir)=itemp
          endif
        endif
        select=arr(k)
        iselect=ind(k)
        return
      else
        mid=(l+ir)/2
        temp=arr(mid)
        arr(mid)=arr(l+1)
        arr(l+1)=temp
        itemp=ind(mid)
        ind(mid)=ind(l+1)
        ind(l+1)=itemp
        if(arr(l+1).gt.arr(ir))then
          temp=arr(l+1)
          arr(l+1)=arr(ir)
          arr(ir)=temp
          itemp=ind(l+1)
          ind(l+1)=ind(ir)
          ind(ir)=itemp
        endif
        if(arr(l).gt.arr(ir))then
          temp=arr(l)
          arr(l)=arr(ir)
          arr(ir)=temp
          itemp=ind(l)
          ind(l)=ind(ir)
          ind(ir)=itemp
        endif
        if(arr(l+1).gt.arr(l))then
          temp=arr(l+1)
          arr(l+1)=arr(l)
          arr(l)=temp
          itemp=ind(l+1)
          ind(l+1)=ind(l)
          ind(l)=itemp
        endif
        i=l+1
        j=ir
        a=arr(l)
        ia=ind(l)
3       continue
          i=i+1
        if(arr(i).lt.a)goto 3
4       continue
          j=j-1
        if(arr(j).gt.a)goto 4
        if(j.lt.i)goto 5
        temp=arr(i)
        arr(i)=arr(j)
        arr(j)=temp
        itemp=ind(i)
        ind(i)=ind(j)
        ind(j)=itemp
        goto 3
5       arr(l)=arr(j)
        arr(j)=a
        ind(l)=ind(j)
        ind(j)=ia
        if(j.ge.k)ir=j-1
        if(j.le.k)l=i
      endif
      goto 1
      END
c
c ----------------------------------------------------------------------------
c
c       findnearest - finds nearest model to input point
c
c       Calls no other routines.
c
c                                               M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
	Subroutine findnearest(smodelt,na_models,ntot,moddim,mopts)

	real		na_models(moddim,*)
	real		smodelt(*)

	common		/findnearestcom/dmin

        dmin = 0
        do i=1,moddim
          b = na_models(i,1)-smodelt(i)
          dmin = dmin + b*b
        end do
        mopts = 1
	do j=2,ntot
           d = 0
           do i=1,moddim
             b = na_models(i,j)-smodelt(i)
             d = d + b*b
           end do
           if(d.lt.dmin)then
             dmin = d
             mopts = j
           end if
        end do

	return
	end
c
c ----------------------------------------------------------------------------
c
c       irandomvalue - generates a random integer between i1 and i2.
c
c       Comments:
c                Uses either Sobol-Antonov_Saleev quasi-sequence
c                or pseudo-random number generator, depending on the 
c                logical variable sobol.
c
c                Assumes either random sequence has been initialized.
c
c                                               M. Sambridge, Aug. 1997
c
c ----------------------------------------------------------------------------
c
        Subroutine irandomvalue (i1,i2,iran)
c
        logical         sobol
        real*4          rval(2)

        common/randomtype/sobol,iseed
c
c                                               Use SAS sequence
        if(sobol)then
           call sobseq(1,rval)
           iran = i1 + int(rval(1)*(i2-i1+1))
        else
           rran = ran3(iseed)
           iran = i1 + int(rran*(i2-i1+1))
        end if

        return
        end
c ----------------------------------------------------------------------------
c
c       transform2sca - transforms model from raw to scaled units.
c
c	Input:
c	      nd		: dimension of parameter space
c	      model_raw(nd)	: model in raw co-ordinates
c	      range(2,nd)	: min and max of parameter space 
c				  in raw co-ordinates.
c	      scales(nd+1)	: range scale factors
c
c	Output:
c	      model_sca(nd)	: model in scaled co-ordinates
c
c	Comments:
c	         This routine transforms a model in raw co-ordinates 
c		 to dimensionless units determined by parameter scale factors.
c
c       Calls no other routines.
c
c                                               M. Sambridge, March 1998
c
c ----------------------------------------------------------------------------
c
        Subroutine transform2sca
     &             (model_raw,nd,range,scales,model_sca)
c
        real*4          model_sca(nd)
        real*4          model_raw(nd)
        real*4          scales(nd+1)
        real*4          range(2,nd)
c
        if(scales(1).eq.0.0)then

           do i=1,nd
              model_sca(i) = model_raw(i)
           end do

        else if(scales(1).eq.-1.0)then

           do i=1,nd
              model_sca(i) =
     &        (model_raw(i)-range(1,i))/(range(2,i)-range(1,i))
           end do

        else

           do i=1,nd
              model_sca(i) = (model_raw(i)-range(1,i))/scales(i+1)
           end do

        end if
c
        return
        end

c
c ----------------------------------------------------------------------------
c
c       transform2raw - transforms model from scaled to raw units.
c
c	Input:
c	      nd		: dimension of parameter space
c	      model_sca(nd)	: model in scaled co-ordinates
c	      range(2,nd)	: min and max of parameter space 
c				  in raw co-ordinates.
c	      scales(nd+1)	: range scale factors
c
c	Output:
c	      model_raw(nd)	: model in scaled co-ordinates
c
c	Comments:
c	         This routine transforms a model in dimensionless scaled 
c		 co-ordinates to input (raw) units.
c
c       Calls no other routines.
c
c                                               M. Sambridge, March 1998
c
c ----------------------------------------------------------------------------
c
        Subroutine transform2raw
     &             (model_sca,nd,range,scales,model_raw)
c
        real*4          model_raw(nd)
        real*4          model_sca(nd)
        real*4          scales(nd+1)
        real*4          range(2,nd)
c
        if(scales(1).eq.0.0)then

           do i=1,nd
              model_raw(i) = model_sca(i)
           end do

        else if(scales(1).eq.-1.0)then

           do i=1,nd
              b = model_sca(i)
              a = 1-b
              model_raw(i) = a*range(1,i) + b*range(2,i)
           end do

        else

           do i=1,nd
              model_raw(i) = range(1,i) + scales(i+1)*model_sca(i)
           end do

        end if
c
        return
        end
c
c ---------------------------------------------------------------------
c
c       write_nad - write a direct access file in
c                   multi-record NAD format
c
c       Input:
c             lu                : logical unit of file
c             fnme              : filename
c             nhmax             : maximum size of array header
c             ndmax             : maximum size of array data
c             nemax             : maximum size of array models
c             iform             : =0 then single record format
c                                 =1 then multi-record format (for large nd)
c
c       Output:
c             nh                : length in bytes of file header
c             nhu               : length in bytes of user portion of header
c             nd                : dimension of parameter space
c             ne                : number of models in ensemble
c             header            : header character string of length nh (char)
c             data(nd)          : array of data values for each model (real*4)
c             models(nd,ne)     : array of model values  (real*4)
c
c       Comments:
c                The direct access NAD file format:
c
c                VARIABLE       TYPE            SIZE IN BYTES
c                nd             int             4
c                ne             int             4
c                nh             int             4
c                nhu            int             4
c                header         character       nh
c                models         real*4          4*nd*ne
c                data           real*4          4*nd
c                tail           real*4          4
c
c                In single record mode a direct access file of length
c                [4x(4+nd*ne+ne+1) + nh] bytes is produced.
c
c                In multi record mode a direct access file of length
c                [(ne+1)*(max(20+nh,4(nd+1))] bytes is produced.
c
c               Calls are made to subroutine read_da.
c
c                This routine assumes that direct access
c                files are opened with the record length specified
c                in bytes. This is the default for most machines
c                but not Dec machines. (Often a compiler option is
c                available on the DEC/compaq to use bytes rather than
c                4-byte words.
c
c                                       M. Sambridge, RSES, November 2001
c
c ---------------------------------------------------------------------
c
      Subroutine write_nad
     &           (lu,fnme,nd,ne,nh,nhu,header,iform,models,data)
c
      real*4            models(nd,ne)
      real*4            data(ne)
      character         header(nh)
      real*4            tail
      character*256     fnme
      logical           warn

      warn = .true.
      warn = .false.

c                                               write new
c                                               multi-record format
      if(iform.eq.1)then

c                                               calculate length of header
         len1 = 4*5+nh
         len2 = 4*(nd+1)
         mul  = 1 + (len1-1)/len2
c        write(*,*)mul
         lenh = mul*len2
         num = ne + mul
         is1 = num*len2
         is2 = 4*(5+nd*ne+ne)+nh

c        write(*,*)' Number of models                         :',ne
c        write(*,*)' Number of dimensions                     :',nd
c        write(*,*)' Original header length in bytes          :',len1
c        write(*,*)' Final header length in bytes             :',lenh
c        write(*,*)' Direct access file record length         :',len2
c        write(*,*)' Number of records                        :',num
c        write(*,*)' Size of nad file in multi-record format  :',is1
c        write(*,*)' Size of nad file in single record format :',is2

c                                                       write header
         open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=lenh)

c                                               write out header
c                                               for multi-record format

         write(lu,rec=1)-mul,nd,ne,nh,nhu,header

         close(lu)
c                                                       write models
         open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=len2)

         do i=1,ne
            call wnad(lu,mul+i,nd,models(1,i),data(i))
         end do
         close(lu)


      else
c                                               write original
c                                               single record format
c
c                                               set total length of nad file
         len = 4+nd*ne+ne+1
         len = 4*len+nh

         write(*,*)' size of nad file = ',len
c                                               open direct access nad file

         open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=len)

         tail = -999.0
         write(lu,rec=1)nd,ne,nh,nhu,header,models,data,tail

         close(lu)

      end if

      return
      end

      Subroutine wnad(lu,i,nd,models,data)

      real*4            models(nd)
      real*4            data

      write(lu,rec=i)models,data

      return
      end
c
c ---------------------------------------------------------------------
c
c       read_nad - read a direct access file in NAD format.
c
c       Input:
c             lu              : logical unit of file
c             fnme            : filename
c             nhmax           : maximum size of array header
c             ndmax           : maximum size of array data
c             nemax           : maximum size of array models
c
c       Output:
c             nh              : total length in bytes of file header
c             nhu             : length in bytes of user written part of header
c             iform           : format for nad file (1=multi-record,0=single)
c             mul             : number of records in the header (with padding)
c             nd              : dimension of parameter space
c             ne              : number of models in ensemble
c             header          : header character string of length nh (char)
c             data(nd)        : array of data values for each model (real*4)
c             models(nd,ne)   : array of model values  (real*4)
c
c       Comments:
c                The direct access NAD file format:
c
c                VARIABLE       TYPE            SIZE IN BYTES
c                nd             int             4
c                ne             int             4
c                nh             int             4
c                nhu            int             4
c                header         character       nh
c                models         real*4          4*nd*ne
c                data           real*4          4*nd
c                tail           real*4          4
c
c                File must contain a single record of length
c                [4x(4+nd*ne+ne+1) + nh] bytes
c
c               Calls are made to subroutine read_da.
c
c                This routine assumes that direct access
c                files are opened with the record length specified
c                in bytes. This is the default for most machines
c                but not Dec machines. (Often a compiler option is
c                available on the DEC/compaq to use bytes rather than
c                4-byte words.
c
c                                       M. Sambridge, RSES, Nov. 2001
c
c ---------------------------------------------------------------------
c
        Subroutine read_nad
     &                     (lu,fnme,nh,nhu,iform,nd,ne,
     &                      nhmax,ndmax,nemax,
     &                      header,data,models)
c
        real*4            models(*)
        real*4            data(*)
        character*(*)     header

        character*256     fnme

        mul = 0
        iform = 0
c                                               read in size of header
        len = 4
        open(lu,file=fnme,status='unknown',
     &       form='unformatted',access='direct',recl=len)
        read(lu,rec=1)mul
        close(lu)
c                                               read in number of models,
c                                               number of dimensions and
c                                               size of header
        if(mul.gt.0)then
c                                               we are in single record format
          len = 16
          open(lu,file=fnme,status='unknown',
     &         form='unformatted',access='direct',recl=len)
          read(lu,rec=1)nd,ne,nh,nhu
          mul = 0
          close(lu)
        else
c                                               we are in multi record format
          len = 20
          open(lu,file=fnme,status='unknown',
     &         form='unformatted',access='direct',recl=len)
          read(lu,rec=1)mul,nd,ne,nh,nhu
          mul = -mul
          close(lu)
          iform = 1
        end if

c                                               check array sizes
        if(nd.gt.ndmax)then
          write(*,*)
          write(*,*)
     &    'Error - maxmimum number of dimensions is too small'
          write(*,*)
     &    '        current maximum number of dimensions =',ndmax
          write(*,*)
     &    '        number of dimensions in input file   =',nd
          write(*,*)'        '
          write(*,*)'Remedy - increase size of parameter ndmax'
          write(*,*)'         to at least this value and recompile'
          write(*,*)'        '
          call na_abort
        end if

        if(ne.gt.nemax)then
          write(*,*)
          write(*,*)
     &    'Error - maxmimum number of models is too small'
          write(*,*)
     &    '        current maximum number of models =',nemax
          write(*,*)
     &    '        number of models in input file   =',ne
          write(*,*)'        '
          write(*,*)'Remedy - increase size of parameter nemax'
          write(*,*)'         to at least this value and recompile'
          write(*,*)'        '
          call na_abort
        end if

        if(nh.gt.nhmax)then
          write(*,*)
          write(*,*)
     &    'Error - maxmimum size of header is too small'
          write(*,*)
     &    '        current maximum size of header =',nhmax
          write(*,*)
     &    '        size of header in input file   =',nh
          write(*,*)'        '
          write(*,*)'Remedy - increase size of parameter nhmax'
          write(*,*)'         to at least this value and recompile'
          write(*,*)'        '
          call na_abort
        end if

        call read_da(lu,fnme,nd,ne,nh,mul,header,models,data)

        return
        end
c
c ---------------------------------------------------------------------
c
c       read_da - read a direct access file containing
c                 ne models with dimension nd, ne data
c                 values and a header of size nh.
c
c       Input:
c             lu                : logical unit of file
c             fnme              : filename
c             nh                : length in bytes of file header (minus padding)
c             mul               : number of records in the header (with padding)
c             nd                : dimension of parameter space
c             ne                : number of models in ensemble
c
c       Output:
c             header            : header character string of length nh (char)
c             data(nd)          : array of data values for each model (real*4)
c             models(nd,ne)     : array of model values  (real*4)
c
c       Comments:
c                The direct access NAD file format:
c
c                VARIABLE       TYPE            SIZE IN BYTES
c                nd             int             4
c                ne             int             4
c                nh             int             4
c                header         character       nh
c                models         real*4          4*nd*ne
c                data           real*4          4*nd
c                tail           real*4          4
c
c                File must contain a single record of length
c                [4x(3+nd*ne+ne+1) + nh] bytes
c
c
c                                       M. Sambridge, RSES, Nov. 2001
c
c ---------------------------------------------------------------------
c
        Subroutine read_da(lu,fnme,nd,ne,nh,mul,header,models,data)
c
        real*4            models(nd,ne)
        real*4            data(ne)
        character         header(nh)
c       real*4            tail

        character*256     fnme
c
c                                              calculate length of header
        iform = 0
        if(mul.ne.0)iform = 1

        lenh  = 4*5+nh
        len   = 4*(nd+1)

        if(iform.eq.1)then

           open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=lenh)

           read(lu,rec=1)idum1,idum2,idum3,idum4,idum5,header

           close(lu)

c          write(*,*)' record length               ',len
c          write(*,*)' header length               ',lenh
c          write(*,*)' Number of records in header ',mul
c
           open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=len)

           do i=1,ne
              call rnad(lu,i+mul,nd,models(1,i),data(i))
           end do

           close(lu)

        else
c                                              read in file as
c                                              a single record
           len = 4+nd*ne+ne
           len = 4*len+nh

           open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=len)

           read(lu,rec=1)i,j,k,kk,header,models,data

           close(lu)

        end if
c
        return
        end

        Subroutine rnad(lu,i,nd,models,data)

        real*4            models(nd)
        real*4            data

        read(lu,rec=i)models,data

        return
        end
c
c ----------------------------------------------------------------------------
c
c       cputime - calls system dependent routine to calculate cputime
c		  since last call.
c
c       Calls dtime.
c						M. Sambridge, June 2001
c
c ----------------------------------------------------------------------------
c
        Function cputime(t1,t2)

	real*4 tarray(2)

	cputime = dtime(tarray)
        t1 = tarray(1)
        t2 = tarray(2)

	return
	end
c
c ----------------------------------------------------------------------------
c
c       NA_header - writes NA-specific information to NAD header.
c
c		    This routine adds various NA-header info to
c		    the header written by the user.
c
c       Calls no other routines.
c
c						M. Sambridge, June 1999
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_header
     &             (lu,fnme,header,nh_max,nh,nd,
     &              range,scales,n1,n2,n3,nhu)

	real*4		  range(2,nd)
	real*4		  scales(nd+1)
        character*(*)     header
        character*256 	  fnme

c                                               calculate total header length
	rlen = 3*nd + 4
        len = 4*rlen+nh
	nhu = nh
	nh_na   = 4*rlen
	nh_tot  = len
c	write(*,*)' nh_user = ',nhu
c	write(*,*)' nh_na   = ',nh_na  
c	write(*,*)' nh_tot  = ',nh_tot 

        if(nh_tot.gt.nh_max)then
           write(*,*)
           write(*,*)' Error - header array too small'
           write(*,*)
           write(*,*)'         current size = ',nh_max
           write(*,*)'        required size = ',nh_tot
           write(*,*)
           write(*,*)' Remedy - adjust nh_max in parameter',
     &                        ' file and recompile'
           write(*,*)
           call na_abort
        end if

c						write out header information
	call write_header
     &       (lu,fnme,len,nd,nh,range,scales,n1,n2,n3,header)

	nh = nh_tot
c						read header information
c						into character string
	call read_header
     &       (lu,fnme,nh,len,header)


c	write(50,*)header(nh_na+1:nh_tot)

	return
	end
c
c ----------------------------------------------------------------------------
c
c       read_header - converts header information into a character
c		      string by writing it to a direct access file
c		      and then reading it back as a character string
c
c       Calls no other routines.
c
c						M. Sambridge, June 1999
c
c ----------------------------------------------------------------------------
c
c                                               open direct access 
c						temporary file
	Subroutine read_header
     &  	   (lu,fnme,nh,len,header)

        character         header(nh)
        character*256 	  fnme

        open(lu,file=fnme,status='unknown',
     &       form='unformatted',access='direct',recl=len)

        read(lu,rec=1)header

        close(lu)

	return
	end
c
c ----------------------------------------------------------------------------
c
c       write_header - converts header information into a character
c		       string by writing it to a direct access file
c		       and then reading it back as a character string
c
c       Calls no other routines.
c
c						M. Sambridge, June 1999
c
c ----------------------------------------------------------------------------
c
c                                               open direct access 
c						temporary file
	Subroutine write_header
     &  	   (lu,fnme,len,nd,nh,
     &              range,scales,n1,n2,n3,header)

	real*4		  range(2,nd)
	real*4		  scales(nd+1)
        character         header(nh)
        character*256 	  fnme

        open(lu,file=fnme,status='unknown',
     &       form='unformatted',access='direct',recl=len)

        write(lu,rec=1)n1,n2,n3,range,scales,header

        close(lu)

	return
	end
c
c ----------------------------------------------------------------------------
c
c       NA_display - writes out current best fit model 
c		     to LU lu_det with misfit information
c
c       Calls no other routines.
c
c						M. Sambridge, Sept. 1999
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_display
     &             (lu_det,model_opt,it,nd,ntot,
     &              mfitmin,mfitminc,mfitmean,mopt)

	real*4		model_opt(*)
	real*4		mfitmin,mfitmean,mfitminc

        write(lu_det,*)' Iteration              ',
     &                 '           : ',it
        write(lu_det,*)' Total number of samples ',
     &                 '          : ',ntot
        write(lu_det,*)
     &  ' Minimum misfit                    : ',mfitmin
        write(lu_det,*)
     &  ' Minimum misfit for this iteration : ',mfitminc
        write(lu_det,*)
     &  ' Mean misfit in this iteration     : ',mfitmean
        write(lu_det,*)
     &  ' Index of best fitting model       : ',mopt
        write(lu_det,*)

c						write out optimum model

	write(lu_det,*)' Parameter   best fitting model'
	do i=1,nd
	   write(lu_det,*)' ',i,' : ',model_opt(i)
	end do
        write(lu_det,100)
	
 100    format(/,72("-")/)
	

	return
	end
c
c ----------------------------------------------------------------------------
c
c       jumble - randomly re-arranges input array  
c
c       Calls ran3 and assumes that it has been initialized.
c
c                                               M. Sambridge, Oct. 1999.
c
c ----------------------------------------------------------------------------
c
	Subroutine jumble(iarr,arr,n)

	integer		iarr(n)
	real*4		arr(n)

c	write(*,*)' input to jumble'
c	write(*,*)(iarr(k),k=1,n)

        rn = n
        do j=1,n
           val = ran3(iseed)
           k = 1 + int(val*rn)
           if(k.eq.n+1)then
	      k = n
           else if(k.gt.n)then
              write(*,*)' error in jumble k'
     &        ,k,' val',val,' rn',rn
              call na_abort
           end if
           ival = iarr(j)
           iarr(j) = iarr(k)
           iarr(k) = ival
           val = arr(j)
           arr(j) = arr(k)
           arr(k) = val
        end do

c	write(*,*)' output of jumble'
c	write(*,*)(iarr(k),k=1,n)

	return
	end
c
c ----------------------------------------------------------------------------
c
c       na_abort - randomly re-arranges input array  
c						Used in place of a stop
c						to ensure that all 
c						processes are stopped
c						in MPI mode
c
c ----------------------------------------------------------------------------
c
	Subroutine na_abort

cifdef MPI
        include "mpif.h"
        integer	ierr
        call mpi_abort(MPI_COMM_WORLD, ierr)
cendif
	stop
	end

